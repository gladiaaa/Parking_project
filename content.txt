

Directory structure:
â””â”€â”€ Backend/
    â”œâ”€â”€ README.md
    â”œâ”€â”€ composer.json
    â”œâ”€â”€ phpunit.xml.dist
    â”œâ”€â”€ public/
    â”‚   â””â”€â”€ index.php
    â”œâ”€â”€ src/
    â”‚   â”œâ”€â”€ bootstrap.php
    â”‚   â”œâ”€â”€ seed.php
    â”‚   â”œâ”€â”€ Application/
    â”‚   â”‚   â””â”€â”€ UseCase/
    â”‚   â”‚       â””â”€â”€ ReservationManagement.php
    â”‚   â”œâ”€â”€ Controller/
    â”‚   â”‚   â”œâ”€â”€ Auth2FAController.php
    â”‚   â”‚   â”œâ”€â”€ AuthController.php
    â”‚   â”‚   â”œâ”€â”€ MeController.php
    â”‚   â”‚   â”œâ”€â”€ OwnerParkingController.php
    â”‚   â”‚   â”œâ”€â”€ ParkingController.php
    â”‚   â”‚   â””â”€â”€ ReservationController.php
    â”‚   â”œâ”€â”€ Domain/
    â”‚   â”‚   â”œâ”€â”€ Entity/
    â”‚   â”‚   â”‚   â”œâ”€â”€ parking.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ Reservation.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ Stationnement.php
    â”‚   â”‚   â”‚   â””â”€â”€ User.php
    â”‚   â”‚   â””â”€â”€ Repository/
    â”‚   â”‚       â”œâ”€â”€ ParkingRepository.php
    â”‚   â”‚       â”œâ”€â”€ ReservationRepository.php
    â”‚   â”‚       â”œâ”€â”€ StationnementRepository.php
    â”‚   â”‚       â”œâ”€â”€ UserRepository.php
    â”‚   â”‚       â””â”€â”€ Exception/
    â”‚   â”‚           â””â”€â”€ DomainException.php
    â”‚   â”œâ”€â”€ Infrastructure/
    â”‚   â”‚   â”œâ”€â”€ Http/
    â”‚   â”‚   â”‚   â”œâ”€â”€ IsGranted.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ Response.php
    â”‚   â”‚   â”‚   â””â”€â”€ Router.php
    â”‚   â”‚   â”œâ”€â”€ Persistence/
    â”‚   â”‚   â”‚   â”œâ”€â”€ SqlParkingRepository.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ SqlReservationRepository.php
    â”‚   â”‚   â”‚   â”œâ”€â”€ SqlStationnementRepository.php
    â”‚   â”‚   â”‚   â””â”€â”€ SqlUserRepository.php
    â”‚   â”‚   â””â”€â”€ Security/
    â”‚   â”‚       â”œâ”€â”€ JwtManager.php
    â”‚   â”‚       â””â”€â”€ PasswordHasher.php
    â”‚   â””â”€â”€ UseCase/
    â”‚       â”œâ”€â”€ CreateReservation.php
    â”‚       â”œâ”€â”€ Auth/
    â”‚       â”‚   â”œâ”€â”€ ConfigureTwoFactorMethod.php
    â”‚       â”‚   â”œâ”€â”€ GetCurrentUser.php
    â”‚       â”‚   â”œâ”€â”€ LoginUser.php
    â”‚       â”‚   â”œâ”€â”€ Mailer.php
    â”‚       â”‚   â”œâ”€â”€ RefreshToken.php
    â”‚       â”‚   â”œâ”€â”€ RegisterUser.php
    â”‚       â”‚   â”œâ”€â”€ SmsSender.php
    â”‚       â”‚   â”œâ”€â”€ StartTwoFactor.php
    â”‚       â”‚   â”œâ”€â”€ TotpVerifier.php
    â”‚       â”‚   â””â”€â”€ VerifyTwoFactor.php
    â”‚       â”œâ”€â”€ Billing/
    â”‚       â”‚   â””â”€â”€ BillingCalculator.php
    â”‚       â”œâ”€â”€ Owner/
    â”‚       â”‚   â”œâ”€â”€ GetMonthlyRevenueForOwner.php
    â”‚       â”‚   â”œâ”€â”€ ListActiveStationnementsForOwner.php
    â”‚       â”‚   â”œâ”€â”€ ListOwnerParkings.php
    â”‚       â”‚   â””â”€â”€ ListParkingReservationsForOwner.php
    â”‚       â”œâ”€â”€ Parking/
    â”‚       â”‚   â”œâ”€â”€ CalculateOccupancy.php
    â”‚       â”‚   â”œâ”€â”€ CheckAvailability.php
    â”‚       â”‚   â”œâ”€â”€ CreateParking.php
    â”‚       â”‚   â”œâ”€â”€ GetOwnerParkings.php
    â”‚       â”‚   â”œâ”€â”€ GetOwnerStatistics.php
    â”‚       â”‚   â”œâ”€â”€ GetParkingDetails.php
    â”‚       â”‚   â””â”€â”€ SearchParkings.php
    â”‚       â””â”€â”€ Reservation/
    â”‚           â”œâ”€â”€ EnterReservation.php
    â”‚           â”œâ”€â”€ ExitReservation.php
    â”‚           â”œâ”€â”€ GetInvoiceHtml.php
    â”‚           â””â”€â”€ GetUserReservations.php
    â””â”€â”€ tests/
        â”œâ”€â”€ Domain/
        â”‚   â””â”€â”€ JwtManagerTest.php
        â”œâ”€â”€ Infrastructure/
        â”‚   â””â”€â”€ Security/
        â”‚       â””â”€â”€ PasswordHasherTest.php
        â””â”€â”€ UseCase/
            â””â”€â”€ Auth/
                â”œâ”€â”€ InMemoryUserRepository.php
                â””â”€â”€ LoginUserTest.php


================================================
FILE: Backend/README.md
================================================
# ğŸš€ Backend - ParkingPartagÃ©

API REST en PHP pour le systÃ¨me de rÃ©servation de parkings.

## ğŸ“‹ PrÃ©requis

- PHP 8.0+
- MySQL 8.0+
- Composer (optionnel)

## ğŸ› ï¸ Installation

### 1. Configuration de la base de donnÃ©es

```bash
# CrÃ©er la base de donnÃ©es
mysql -u root -p < sql/001_init_core.sql

# InsÃ©rer les donnÃ©es de test
mysql -u root -p < sql/002_insert_parkings.sql
```

### 2. Configuration de l'environnement

```bash
# Copier le fichier .env.example
cp .env.example .env

# Ã‰diter .env avec vos paramÃ¨tres
nano .env
```

### 3. DÃ©marrer le serveur PHP

```bash
# Depuis le dossier Backend
cd Backend
php -S localhost:8001 -t public
```

## ğŸ“Š Structure de la base de donnÃ©es

### Tables principales

- **users** : Utilisateurs (user/owner)
- **parkings** : Parkings disponibles
- **parking_services** : Services proposÃ©s par parking
- **parking_type_vehicules** : Types de vÃ©hicules acceptÃ©s
- **reservations** : RÃ©servations des utilisateurs
- **stationnements** : Stationnements actifs

## ğŸ”Œ Endpoints API

### Authentification
- `POST /api/auth/login` - Connexion
- `POST /api/auth/register` - Inscription
- `GET /api/auth/profile` - Profil utilisateur

### Parkings
- `GET /api/parkings` - Liste des parkings
- `GET /api/parkings/search` - Recherche de parkings
- `GET /api/parkings/:id` - DÃ©tails d'un parking

### RÃ©servations
- `GET /api/reservations` - Mes rÃ©servations
- `POST /api/reservations` - CrÃ©er une rÃ©servation
- `DELETE /api/reservations/:id` - Annuler une rÃ©servation

## ğŸ” SÃ©curitÃ©

- Hashage des mots de passe avec bcrypt
- Tokens JWT pour l'authentification
- Validation des donnÃ©es
- Protection CORS

## ğŸ‘¥ Pour le groupe

1. Cloner le projet
2. Installer MySQL
3. ExÃ©cuter les scripts SQL dans l'ordre
4. Configurer le `.env`
5. DÃ©marrer le serveur PHP

## ğŸ“ Notes

- Le frontend utilise actuellement un mock API (`apiService.js`)
- Pour connecter le vrai backend, modifier `API_BASE_URL` dans `apiService.js`
- Les mots de passe de test : `password123` (hashÃ© avec bcrypt)








================================================
FILE: Backend/composer.json
================================================
{
  "require": {
    "php": "^8.2",
    "firebase/php-jwt": "^6.10",
    "vlucas/phpdotenv": "^5.6"
  },
  "autoload": {
    "psr-4": {
      "App\\": "src/"
    }
  },
  "require-dev": {
    "phpunit/phpunit": "11"
  }
}



================================================
FILE: Backend/phpunit.xml.dist
================================================
<?xml version="1.0" encoding="UTF-8"?>
<phpunit
    bootstrap="vendor/autoload.php"
    colors="true"
>
    <testsuites>
        <testsuite name="Parking Test Suite">
            <directory>tests</directory>
        </testsuite>
    </testsuites>

    <source>
        <include>
            <directory suffix=".php">src</directory>
        </include>
    </source>
</phpunit>



================================================
FILE: Backend/public/index.php
================================================
<?php
declare(strict_types=1);

require __DIR__ . '/../src/bootstrap.php';

// bootstrap.php a dÃ©jÃ  appelÃ© cors() + gÃ©rÃ© OPTIONS
// Donc ici on ne refait pas cors/preflight.

$method = $_SERVER['REQUEST_METHOD'] ?? 'GET';
$path   = parse_url($_SERVER['REQUEST_URI'] ?? '/', PHP_URL_PATH) ?: '/';

$router->dispatch($method, $path);



================================================
FILE: Backend/src/bootstrap.php
================================================
<?php
declare(strict_types=1);

require __DIR__ . '/../vendor/autoload.php';

use Dotenv\Dotenv;
use App\Infrastructure\Http\Router;
use App\Infrastructure\Security\JwtManager;
use App\Infrastructure\Security\PasswordHasher;

use App\Infrastructure\Persistence\SqlUserRepository;
use App\Infrastructure\Persistence\SqlParkingRepository;
use App\Infrastructure\Persistence\SqlReservationRepository;
use App\Infrastructure\Persistence\SqlStationnementRepository;

use App\Controller\AuthController;
use App\Controller\Auth2FAController;
use App\Controller\MeController;
use App\Controller\ReservationController;
use App\Controller\ParkingController;
use App\Controller\OwnerParkingController;

use App\UseCase\Auth\LoginUser;
use App\UseCase\Auth\RegisterUser;
use App\UseCase\Auth\RefreshToken;
use App\UseCase\Auth\StartTwoFactor;
use App\UseCase\Auth\VerifyTwoFactor;
use App\UseCase\Auth\Mailer;
use App\UseCase\Auth\SmsSender;
use App\UseCase\Auth\TotpVerifier;

use App\UseCase\Parking\GetParkingDetails;
use App\UseCase\Parking\CheckAvailability;
use App\UseCase\Parking\CalculateOccupancy;
use App\UseCase\Parking\CreateParking;


use App\UseCase\Billing\BillingCalculator;
use App\UseCase\CreateReservation;
use App\UseCase\Reservation\EnterReservation;
use App\UseCase\Reservation\ExitReservation;
use App\UseCase\Reservation\GetInvoiceHtml;

use App\UseCase\Owner\ListOwnerParkings;
use App\UseCase\Owner\ListParkingReservationsForOwner;
use App\UseCase\Owner\ListActiveStationnementsForOwner;
use App\UseCase\Owner\GetMonthlyRevenueForOwner;


// =====================
// ENV
// =====================
$dotenv = Dotenv::createImmutable(__DIR__ . '/..');
$dotenv->load();

// =====================
// Helpers
// =====================
function cors(): void
{
    header('Access-Control-Allow-Origin: ' . ($_ENV['APP_ORIGIN'] ?? '*'));
    header('Access-Control-Allow-Credentials: true');
    header('Access-Control-Allow-Headers: Content-Type, X-Requested-With');
    header('Access-Control-Allow-Methods: GET, POST, PUT, PATCH, DELETE, OPTIONS');
    header('Content-Type: application/json; charset=utf-8');
}

function pdo(): PDO
{
    static $pdo = null;
    if ($pdo) return $pdo;

    $dsn = 'mysql:host=' . $_ENV['DB_HOST'] .
        ';dbname=' . $_ENV['DB_NAME'] .
        ';charset=' . ($_ENV['DB_CHARSET'] ?? 'utf8mb4');

    $pdo = new PDO($dsn, $_ENV['DB_USER'], $_ENV['DB_PASS'], [
        PDO::ATTR_ERRMODE => PDO::ERRMODE_EXCEPTION,
        PDO::ATTR_DEFAULT_FETCH_MODE => PDO::FETCH_ASSOC,
    ]);

    return $pdo;
}

// =====================
// CORS + preflight
// =====================
cors();
if (($_SERVER['REQUEST_METHOD'] ?? '') === 'OPTIONS') {
    http_response_code(204);
    exit;
}

// =====================
// Infra / Repos
// =====================
$db = pdo();

$userRepository = new SqlUserRepository($db);
$parkingRepository = new SqlParkingRepository($db);
$reservationRepository = new SqlReservationRepository($db);
$stationnementRepository = new SqlStationnementRepository($db);

$passwordHasher = new PasswordHasher();

$jwtManager = new JwtManager(
    $_ENV['JWT_SECRET'],
    (int)$_ENV['JWT_ACCESS_TTL'],
    (int)$_ENV['JWT_REFRESH_TTL']
);

// =====================
// Fake providers (2FA)
// =====================
$mailer = new class implements Mailer {
    public function sendTwoFactorCodeEmail(string $to, string $code): void
    {
        error_log("[2FA EMAIL] $to -> code $code");
    }
};

$smsSender = new class implements SmsSender {
    public function sendTwoFactorSms(string $phone, string $code): void
    {
        error_log("[2FA SMS] $phone -> code $code");
    }
};

$totpVerifier = new class implements TotpVerifier {
    public function verify(string $secret, string $code): bool
    {
        return true;
    }
};

// =====================
// UseCases
// =====================
// Auth
$loginUser = new LoginUser($userRepository, $passwordHasher);
$registerUser = new RegisterUser($userRepository, $passwordHasher);
$refreshToken = new RefreshToken($jwtManager, $userRepository);
$startTwoFA = new StartTwoFactor($userRepository, $mailer, $smsSender);
$verify2FA = new VerifyTwoFactor($userRepository, $jwtManager, $totpVerifier);

// Parking
$getParkingDetails = new GetParkingDetails($parkingRepository);
$occupancy = new CalculateOccupancy($stationnementRepository, $reservationRepository);
$checkAvailability = new CheckAvailability($parkingRepository, $occupancy);
$createParking = new CreateParking($parkingRepository);

// Reservations
$createReservation = new CreateReservation($parkingRepository, $reservationRepository, $occupancy);

$billing = new BillingCalculator();
$enterReservation = new EnterReservation($reservationRepository, $stationnementRepository);
$exitReservation = new ExitReservation($reservationRepository, $stationnementRepository, $parkingRepository, $billing);
$getInvoiceHtml = new GetInvoiceHtml($reservationRepository, $stationnementRepository, $parkingRepository);

// Owner
$listOwnerParkings = new ListOwnerParkings($parkingRepository);
$listParkingReservationsForOwner = new ListParkingReservationsForOwner($parkingRepository, $reservationRepository);
$listActiveStationnementsForOwner = new ListActiveStationnementsForOwner($parkingRepository, $stationnementRepository);
$getMonthlyRevenueForOwner = new GetMonthlyRevenueForOwner($parkingRepository, $stationnementRepository);
// =====================
// Controllers
// =====================
$meController = new MeController($jwtManager, $userRepository);

$authController = new AuthController(
    $loginUser,
    $refreshToken,
    $registerUser,
    $startTwoFA,
    $jwtManager
);

$auth2FAController = new Auth2FAController($verify2FA, $jwtManager);


$ownerParkingController = new OwnerParkingController(
    $jwtManager,
    $listOwnerParkings,
    $listParkingReservationsForOwner,
    $listActiveStationnementsForOwner,
    $createParking,
    $getMonthlyRevenueForOwner
);

$parkingController = new ParkingController(
    $jwtManager,
    $getParkingDetails,
    $checkAvailability,
    $stationnementRepository
);

$reservationController = new ReservationController(
    $createReservation,
    $reservationRepository,
    $jwtManager,
    $enterReservation,
    $exitReservation,
    $getInvoiceHtml
);



// =====================
// Router
// =====================
$router = new Router();

$router
    ->get('/health', fn() => print json_encode(['ok' => true]))

    // Auth / me
    ->get('/api/me', [$meController, 'me'])
    ->post('/api/auth/login', [$authController, 'login'])
    ->post('/api/auth/register', [$authController, 'register'])
    ->post('/api/auth/refresh', [$authController, 'refresh'])
    ->post('/api/auth/logout', [$authController, 'logout'])
    ->post('/api/auth/2fa/verify', [$auth2FAController, 'verify'])

    // Parking
    ->get('/api/parkings/details', [$parkingController, 'details'])
    ->get('/api/parkings/availability', [$parkingController, 'availability'])
    ->get('/api/parkings/occupancy-now', [$parkingController, 'occupancyNow'])

    // Owner
    ->get('/api/owner/parkings', [$ownerParkingController, 'listMyParkings'])
    ->get('/api/owner/parkings/{id}/reservations', [$ownerParkingController, 'listParkingReservations'])
    ->get('/api/owner/parkings/{id}/stationnements/active', [$ownerParkingController, 'listActiveStationnements'])
    ->get('/api/owner/parkings/{id}/revenue', [$ownerParkingController, 'monthlyRevenue'])
    ->post('/api/owner/parkings', [$ownerParkingController, 'createParking'])

    // Reservations
    ->get('/api/reservations/me', [$reservationController, 'myReservations'])
    ->post('/api/reservations', [$reservationController, 'create'])
    ->post('/api/reservations/{id}/enter', [$reservationController, 'enter'])
    ->post('/api/reservations/{id}/exit', [$reservationController, 'exit'])
    ->get('/api/reservations/{id}/invoice', [$reservationController, 'invoice']);




================================================
FILE: Backend/src/seed.php
================================================
<?php
require __DIR__ . '/bootstrap.php';

$pdo = pdo();

echo "Seeding database...\n";

// 1. Create Owner
$stmt = $pdo->prepare('SELECT id FROM users WHERE email = ?');
$stmt->execute(['owner@example.com']);
$owner = $stmt->fetch();

if (!$owner) {
    $stmt = $pdo->prepare("INSERT INTO users (email, password_hash, firstname, lastname, role, api_token) VALUES (?, ?, ?, ?, ?, ?)");
    $hash = password_hash('password123', PASSWORD_DEFAULT);
    $token = bin2hex(random_bytes(32));
    $stmt->execute(['owner@example.com', $hash, 'Owner', 'Demo', 'owner', $token]);
    $ownerId = $pdo->lastInsertId();
    echo "Created owner (id: $ownerId)\n";
} else {
    $ownerId = $owner['id'];
    echo "Owner exists (id: $ownerId)\n";
}

// 2. Insert Parkings
$parkings = [
    ['Parking OpÃ©ra Premium', '15 Rue Scribe, 75009 Paris', 'Paris', 48.8706, 2.3319, 150, 3.50, 25.00, 280.00, '00:00:00', '23:59:59', 4.8],
    ['Station ChÃ¢telet', '1 Place du ChÃ¢telet, 75001 Paris', 'Paris', 48.8584, 2.3470, 200, 4.00, 30.00, 320.00, '00:00:00', '23:59:59', 4.9],
    ['Parking Gare du Nord', '18 Rue de Dunkerque, 75010 Paris', 'Paris', 48.8809, 2.3553, 300, 3.00, 22.00, 250.00, '00:00:00', '23:59:59', 4.6],
    ['Park Saint-Lazare', '108 Rue Saint-Lazare, 75008 Paris', 'Paris', 48.8756, 2.3262, 120, 4.50, 35.00, 350.00, '06:00:00', '22:00:00', 4.7],
    ['Parking Bastille Central', '120 Rue de Lyon, 75012 Paris', 'Paris', 48.8522, 2.3697, 180, 3.20, 24.00, 270.00, '00:00:00', '23:59:59', 4.5],
    ['Lyon Part-Dieu Premium', '21 Boulevard Vivier Merle, 69003 Lyon', 'Lyon', 45.7606, 4.8564, 250, 2.80, 20.00, 220.00, '00:00:00', '23:59:59', 4.9],
    ['Station Bellecour', '12 Place Bellecour, 69002 Lyon', 'Lyon', 45.7578, 4.8320, 180, 3.50, 26.00, 280.00, '00:00:00', '23:59:59', 4.7],
    ['Parking Vieux-Port', '46 Quai du Port, 13002 Marseille', 'Marseille', 43.2965, 5.3698, 220, 3.00, 22.00, 240.00, '00:00:00', '23:59:59', 4.6]
];

$stmtCheck = $pdo->prepare('SELECT id FROM parkings WHERE nom = ?');
$stmtInsert = $pdo->prepare("INSERT INTO parkings (owner_id, nom, adresse, ville, latitude, longitude, nombre_places, tarif_horaire, tarif_journalier, tarif_mensuel, horaire_ouverture, horaire_fermeture, note) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");

foreach ($parkings as $p) {
    $stmtCheck->execute([$p[0]]);
    if (!$stmtCheck->fetch()) {
        $stmtInsert->execute(array_merge([$ownerId], $p));
        echo "Inserted parking: {$p[0]}\n";
        $pId = $pdo->lastInsertId();

        // Add services and vehicles
        $services = ['Couvert', 'SÃ©curisÃ©', 'VidÃ©o-surveillance', 'Bornes Ã©lectriques', 'AccÃ¨s handicapÃ©'];
        $vehicles = ['Voiture', 'Moto', 'VÃ©lo', 'Utilitaire'];
        
        // Randomly assign services and vehicles
        $myServices = array_rand(array_flip($services), rand(2, 5));
        if (!is_array($myServices)) $myServices = [$myServices];
        
        $stmtSvc = $pdo->prepare("INSERT INTO parking_services (parking_id, service) VALUES (?, ?)");
        foreach ($myServices as $svc) {
            $stmtSvc->execute([$pId, $svc]);
        }

        $myVehicles = array_rand(array_flip($vehicles), rand(1, 3));
        if (!is_array($myVehicles)) $myVehicles = [$myVehicles];

        $stmtVeh = $pdo->prepare("INSERT INTO parking_type_vehicules (parking_id, type_vehicule) VALUES (?, ?)");
        foreach ($myVehicles as $veh) {
            $stmtVeh->execute([$pId, $veh]);
        }
    }
}

echo "Seeding complete.\n";



================================================
FILE: Backend/src/Application/UseCase/ReservationManagement.php
================================================
<?php
declare(strict_types=1);

namespace App\Application\UseCase;

use App\Domain\Repository\ParkingReservationRepository;
use App\Domain\Entity\parking;
use Exception;

/**
 * La classe ReservationManagement regroupe les Cas d'Utilisation (Use Cases) liÃ©s Ã  la rÃ©servation.
 * Elle sert de point d'entrÃ©e pour la logique d'application depuis le ContrÃ´leur.
 */
class ReservationManagement
{

    public function __construct(
        private ParkingReservationRepository $parkingRepository
    ) {
    }

    /**
     * Cas d'utilisation: RÃ©server une place de parking.
     * C'est ici que la logique mÃ©tier rÃ©side (vÃ©rification des rÃ¨gles).
     * @param int $placeId L'identifiant de la place Ã  rÃ©server.
     * @param int $userId L'identifiant de l'utilisateur.
     * @throws Exception Si la place est dÃ©jÃ  serve.
     */
    public function reserverPlace(int $placeId, int $userId): void
    {

    }

}


================================================
FILE: Backend/src/Controller/Auth2FAController.php
================================================
<?php
declare(strict_types=1);

namespace App\Controller;

use App\Infrastructure\Http\Response;
use App\Infrastructure\Security\JwtManager;
use App\UseCase\Auth\VerifyTwoFactor;

final class Auth2FAController
{
    public function __construct(
        private VerifyTwoFactor $verifyTwoFactor,
        private JwtManager $jwt,
    ) {}

    public function verify(): void
    {
        $data = json_decode(file_get_contents('php://input'), true) ?? [];
        $code = (string)($data['code'] ?? '');

        // On lit le token "pending 2FA" (P2_AUTH)
        $p2 = $this->jwt->readPending2FA();
        if (!$p2 || ($p2['typ'] ?? '') !== 'p2') {
            Response::json(['error' => 'Missing 2FA session'], 401);
            return;
        }

        $userId = (int)($p2['sub'] ?? 0);
        if ($userId <= 0) {
            Response::json(['error' => 'Invalid 2FA context'], 401);
            return;
        }

        try {
            // Use case = logique mÃ©tier
            $tokens = $this->verifyTwoFactor->execute($userId, $code);
        } catch (\Throwable) {
            Response::json(['error' => 'Invalid 2FA'], 401);
            return;
        }

        // Pose les cookies ACCESS / REFRESH
        $this->jwt->setAccessCookie($tokens['access_token']);
        $this->jwt->setRefreshCookie($tokens['refresh_token']);

        // On dÃ©truit le cookie P2_AUTH
        $this->jwt->setPending2FACookie(''); // ou setcookie('P2_AUTH', '', time()-3600, '/');

        Response::json(['ok' => true]);
    }

    public function resend(): void
    {
        // Ã  implÃ©menter si tu veux renvoyer un code, pour lâ€™instant juste OK
        Response::json(['ok' => true]);
    }
}



================================================
FILE: Backend/src/Controller/AuthController.php
================================================
<?php
declare(strict_types=1);

namespace App\Controller;

use App\Infrastructure\Http\Response;
use App\Infrastructure\Security\JwtManager;
use App\UseCase\Auth\LoginUser;
use App\UseCase\Auth\RefreshToken;
use App\UseCase\Auth\RegisterUser;
use App\UseCase\Auth\StartTwoFactor;

final class AuthController
{
    public function __construct(
        private LoginUser $loginUser,
        private RefreshToken $refreshToken,
        private RegisterUser $registerUser,
        private StartTwoFactor $startTwoFactor,
        private JwtManager $jwt,
    ) {
    }

    /** POST /api/auth/login */
    public function login(): void
    {
        $data = json_decode(file_get_contents('php://input'), true) ?? [];
        $email = (string) ($data['email'] ?? '');
        $password = (string) ($data['password'] ?? '');

        try {
            $result = $this->loginUser->execute($email, $password);

            if (!$result['success']) {
                Response::json(['error' => 'Invalid credentials'], 401);
                return;
            }

            // Si 2FA requise : pas de JWT dÃ©finitifs, juste un pending token
            if (!empty($result['two_factor_required']) && $result['two_factor_required'] === true) {
                $userId = $result['user_id'];

                $p2 = $this->jwt->issuePending2FAToken($userId);
                $this->jwt->setPending2FACookie($p2);

                $this->startTwoFactor->execute($userId);

                Response::json(['status' => '2fa_required']);
                return;
            }

            // Pas de 2FA â†’ on gÃ©nÃ¨re les vrais tokens
            $userId = $result['user_id'];
            $role = $result['role'];

            [$access, $refresh] = $this->jwt->issueFor($userId, $role);
            $this->jwt->setAccessCookie($access);
            $this->jwt->setRefreshCookie($refresh);

            Response::json(['ok' => true]);
        } catch (\Throwable) {
            Response::json(['error' => 'Invalid credentials'], 401);
        }
    }

    /** POST /api/auth/register */
    public function register(): void
{
    $data = json_decode(file_get_contents('php://input'), true) ?? [];

    $email = $data['email'] ?? '';
    $password = $data['password'] ?? '';
    $role = $data['role'] ?? 'USER';
    $firstname = $data['firstname'] ?? null;
    $lastname = $data['lastname'] ?? null;

    try {
        $user = $this->registerUser->execute(
            $email,
            $password,
            strtoupper($role),
            $firstname,
            $lastname
        );

        // Login automatique
        [$access, $refresh] = $this->jwt->issueFor($user['id'], $user['role']);
        $this->jwt->setAccessCookie($access);
        $this->jwt->setRefreshCookie($refresh);

        Response::json([
            'success' => true,
            'user' => $user,
        ], 201);

    } catch (\RuntimeException $e) {
        Response::json(['error' => $e->getMessage()], 409);
    } catch (\Throwable $e) {
        Response::json(['error' => 'Error registering user'], 400);
    }
}

    /** POST /api/auth/refresh */
    public function refresh(): void
    {
        $result = $this->refreshToken->execute();

        if (!$result) {
            Response::json(['error' => 'Invalid refresh'], 401);
            return;
        }

        $this->jwt->setAccessCookie($result['access']);
        Response::json(['ok' => true]);
    }

    /** POST /api/auth/logout */
    public function logout(): void
    {
        $this->jwt->clearAuthCookies();
        Response::json(['ok' => true]);
    }
}



================================================
FILE: Backend/src/Controller/MeController.php
================================================
<?php
declare(strict_types=1);

namespace App\Controller;

use App\Infrastructure\Http\Response;
use App\Infrastructure\Security\JwtManager;
use App\Domain\Repository\UserRepository;

final class MeController
{
    public function __construct(
        private JwtManager $jwt,
        private UserRepository $users,
    ) {}

    /** GET /api/me */
    public function me(): void
    {
        // On lit le JWT d'accÃ¨s depuis le cookie ACCESS_TOKEN
        $payload = $this->jwt->readAccessFromCookie();

        if (!$payload || ($payload['typ'] ?? '') !== 'access') {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        $userId = (int)($payload['sub'] ?? 0);
        if ($userId <= 0) {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        $user = $this->users->findById($userId);
        if (!$user) {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        Response::json([
            'id'    => $user->id(),
            'email' => $user->email(),
            'role'  => $user->role(),
            'firstname' => $user->firstname(),
            'lastname' => $user->lastname(),
        ]);
    }
}



================================================
FILE: Backend/src/Controller/OwnerParkingController.php
================================================
<?php
declare(strict_types=1);

namespace App\Controller;

use App\Infrastructure\Http\Response;
use App\Infrastructure\Http\IsGranted;
use App\Infrastructure\Security\JwtManager;
use App\UseCase\Owner\ListOwnerParkings;
use App\UseCase\Owner\ListParkingReservationsForOwner;
use App\UseCase\Owner\ListActiveStationnementsForOwner;
use App\UseCase\Owner\GetMonthlyRevenueForOwner;
use App\UseCase\Parking\CreateParking;


final class OwnerParkingController
{
    public function __construct(
        private JwtManager $jwt,
        private ListOwnerParkings $listOwnerParkings,
        private ListParkingReservationsForOwner $listParkingReservationsForOwner,
        private ListActiveStationnementsForOwner $listActiveStationnementsForOwner,
        private CreateParking $createParking,
        private GetMonthlyRevenueForOwner $getMonthlyRevenueForOwner,

    ) {
    }


    public function jwt(): JwtManager
    {
        return $this->jwt;
    }

    #[IsGranted('OWNER')]
    public function createParking(): void
    {
        $payload = $this->jwt->readAccessFromCookie();
        if (!$payload) {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        $ownerId = (int) ($payload['sub'] ?? 0);
        $data = json_decode(file_get_contents('php://input') ?: '[]', true) ?: [];

        try {
            $result = $this->createParking->execute($ownerId, $data);
            Response::json(['success' => true] + $result, 201);
        } catch (\Throwable $e) {
            Response::json(['success' => false, 'error' => $e->getMessage()], 400);
        }
    }


    #[IsGranted('OWNER')]
    public function listMyParkings(): void
    {
        $payload = $this->jwt->readAccessFromCookie();
        if (!$payload) {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        $ownerId = (int) ($payload['sub'] ?? 0);
        $data = $this->listOwnerParkings->execute($ownerId);

        Response::json(['data' => $data], 200);
    }

    #[IsGranted('OWNER')]
    public function listParkingReservations(int $id): void
    {
        $payload = $this->jwt->readAccessFromCookie();
        if (!$payload) {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        $ownerId = (int) ($payload['sub'] ?? 0);
        $from = isset($_GET['from']) ? (string) $_GET['from'] : null;
        $to = isset($_GET['to']) ? (string) $_GET['to'] : null;

        $data = $this->listParkingReservationsForOwner->execute(
            ownerId: $ownerId,
            parkingId: $id,
            from: $from,
            to: $to
        );

        Response::json(['data' => $data], 200);
    }

    #[IsGranted('OWNER')]
    public function listActiveStationnements(int $id): void
    {
        $payload = $this->jwt->readAccessFromCookie();
        if (!$payload) {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        $ownerId = (int) ($payload['sub'] ?? 0);

        try {
            $data = $this->listActiveStationnementsForOwner->execute($ownerId, $id);
            Response::json(['data' => $data], 200);
        } catch (\RuntimeException $e) {
            $msg = $e->getMessage();
            $code = ($msg === 'AccÃ¨s refusÃ©') ? 403 : 404;
            Response::json(['error' => $msg], $code);
        }
    }
    #[IsGranted('OWNER')]
    public function monthlyRevenue(int $id): void
    {
        $payload = $this->jwt->readAccessFromCookie();
        if (!$payload) {
            Response::json(['error' => 'Unauthorized'], 401);
            return;
        }

        $ownerId = (int) ($payload['sub'] ?? 0);
        $month = (string) ($_GET['month'] ?? '');

        try {
            $data = $this->getMonthlyRevenueForOwner->execute($ownerId, $id, $month);
            Response::json(['data' => $data], 200);
        } catch (\RuntimeException $e) {
            $msg = $e->getMessage();
            $code = ($msg === 'AccÃ¨s refusÃ©') ? 403 : 400;
            if ($msg === 'Parking not found')
                $code = 404;
            Response::json(['error' => $msg], $code);
        }
    }

}



================================================
FILE: Backend/src/Controller/ParkingController.php
================================================
<?php
declare(strict_types=1);

namespace App\Controller;

use App\Infrastructure\Http\Response;
use App\Infrastructure\Http\IsGranted;
use App\Infrastructure\Security\JwtManager;
use App\UseCase\Parking\GetParkingDetails;
use App\UseCase\Parking\CheckAvailability;
use App\Domain\Repository\StationnementRepository;

final class ParkingController
{
    public function __construct(
        private readonly JwtManager $jwt,
        private readonly GetParkingDetails $getParkingDetails,
        private readonly CheckAvailability $checkAvailability,
        private readonly StationnementRepository $stationnementRepo
    ) {}

    public function jwt(): JwtManager
    {
        return $this->jwt;
    }

    // GET /api/parkings/details?id=1
    public function details(): void
    {
        $id = (int)($_GET['id'] ?? 0);
        if ($id <= 0) {
            Response::json(['success' => false, 'error' => 'Missing id'], 400);
            return;
        }

        try {
            $parking = $this->getParkingDetails->execute($id);
            Response::json(['success' => true, 'parking' => $parking], 200);
        } catch (\Throwable $e) {
            Response::json(['success' => false, 'error' => $e->getMessage()], 404);
        }
    }

    // GET /api/parkings/availability?parking_id=1&start_at=...&end_at=...
    #[IsGranted('USER')]
    public function availability(): void
    {
        try {
            $data = [
                'parking_id' => $_GET['parking_id'] ?? null,
                'start_at'   => $_GET['start_at'] ?? null,
                'end_at'     => $_GET['end_at'] ?? null,
            ];

            $result = $this->checkAvailability->execute($data);
            Response::json($result, 200);
        } catch (\Throwable $e) {
            Response::json(['success' => false, 'error' => $e->getMessage()], 400);
        }
    }
    // GET /api/parkings/occupancy-now?parking_id=2
public function occupancyNow(): void
{
    $parkingId = (int)($_GET['parking_id'] ?? 0);
    if ($parkingId <= 0) {
        Response::json(['success' => false, 'error' => 'Missing parking_id'], 400);
        return;
    }

    try {
        $parking = $this->getParkingDetails->execute($parkingId);
        $capacity = (int)($parking['capacity'] ?? 0);

        // IMPORTANT: countActiveByParkingId vient du repo stationnements
        $occupied = $this->stationnementRepo->countActiveByParkingId($parkingId);
        $remaining = max(0, $capacity - $occupied);

        Response::json([
            'parking_id' => $parkingId,
            'capacity' => $capacity,
            'occupied_now' => $occupied,
            'remaining_now' => $remaining,
            'available_now' => $remaining > 0,
        ], 200);
    } catch (\Throwable $e) {
        Response::json(['success' => false, 'error' => $e->getMessage()], 404);
    }
}

}



================================================
FILE: Backend/src/Controller/ReservationController.php
================================================
<?php
declare(strict_types=1);

namespace App\Controller;

use App\Domain\Repository\ReservationRepository;
use App\Infrastructure\Http\IsGranted;
use App\Infrastructure\Http\Response;
use App\Infrastructure\Security\JwtManager;
use App\UseCase\CreateReservation;
use App\UseCase\Reservation\EnterReservation;
use App\UseCase\Reservation\ExitReservation;
use App\UseCase\Reservation\GetInvoiceHtml;

final class ReservationController
{
    public function __construct(
        private readonly CreateReservation $createReservation,
        private readonly ReservationRepository $reservationRepository,
        private readonly JwtManager $jwt,
        private readonly EnterReservation $enterReservation,
        private readonly ExitReservation $exitReservation,
        private readonly GetInvoiceHtml $getInvoiceHtml
    ) {}

    // Pour ton Router/IsGranted
    public function jwt(): JwtManager
    {
        return $this->jwt;
    }

    private function requireUserId(): int
    {
        $payload = $this->jwt->readAccessFromCookie();

        if (!$payload || ($payload['typ'] ?? '') !== 'access') {
            Response::json(['error' => 'Unauthorized'], 401);
            exit;
        }

        $userId = (int)($payload['sub'] ?? 0);
        if ($userId <= 0) {
            Response::json(['error' => 'Unauthorized'], 401);
            exit;
        }

        return $userId;
    }

    #[IsGranted('USER')]
    public function create(): void
    {
        $userId = $this->requireUserId();

        $data = json_decode(file_get_contents('php://input'), true) ?? [];

        $parkingId = (int)($data['parking_id'] ?? 0);
        $startAt = (string)($data['start_at'] ?? '');
        $endAt = (string)($data['end_at'] ?? '');
        $vehicleType = (string)($data['vehicle_type'] ?? '');
        $amount = (float)($data['amount'] ?? -1);

        if ($parkingId <= 0 || $startAt === '' || $endAt === '' || $vehicleType === '' || $amount < 0) {
            Response::json(['error' => 'Missing fields'], 400);
            return;
        }

        try {
            $res = $this->createReservation->execute(
                $userId,
                $parkingId,
                $startAt,
                $endAt,
                $vehicleType,
                $amount
            );

            Response::json([
                'id' => $res->id(),
                'user_id' => $res->userId(),
                'parking_id' => $res->parkingId(),
                'start_at' => $res->startAt()->format(DATE_ATOM),
                'end_at' => $res->endAt()->format(DATE_ATOM),
                'vehicle_type' => $res->vehicleType(),
                'amount' => $res->amount(),
                'created_at' => $res->createdAt()->format(DATE_ATOM),
            ], 201);
        } catch (\Throwable $e) {
            Response::json(['error' => $e->getMessage()], 400);
        }
    }

    #[IsGranted('USER')]
    public function myReservations(): void
    {
        $userId = $this->requireUserId();

        try {
            $rows = $this->reservationRepository->findByUserId($userId);

            Response::json([
                'data' => array_map(static fn($r) => [
                    'id' => $r->id(),
                    'user_id' => $r->userId(),
                    'parking_id' => $r->parkingId(),
                    'start_at' => $r->startAt()->format(DATE_ATOM),
                    'end_at' => $r->endAt()->format(DATE_ATOM),
                    'vehicle_type' => $r->vehicleType(),
                    'amount' => $r->amount(),
                    'created_at' => $r->createdAt()->format(DATE_ATOM),
                ], $rows),
            ], 200);
        } catch (\Throwable $e) {
            Response::json(['error' => $e->getMessage()], 400);
        }
    }

    #[IsGranted('USER')]
    public function enter(int $id): void
    {
        $userId = $this->requireUserId();

        try {
            $st = $this->enterReservation->execute($userId, $id);

            Response::json([
                'success' => true,
                'stationnement_id' => $st->id(),
                'reservation_id' => $st->reservationId(),
                'entered_at' => $st->enteredAt()->format(DATE_ATOM),
            ], 200);
        } catch (\Throwable $e) {
            Response::json(['success' => false, 'error' => $e->getMessage()], 400);
        }
    }

    #[IsGranted('USER')]
    public function exit(int $id): void
    {
        $userId = $this->requireUserId();

        try {
            $result = $this->exitReservation->execute($userId, $id);
            Response::json(['success' => true] + $result, 200);
        } catch (\Throwable $e) {
            Response::json(['success' => false, 'error' => $e->getMessage()], 400);
        }
    }

    #[IsGranted('USER')]
    public function invoice(int $id): void
    {
        $userId = $this->requireUserId();

        try {
            $html = $this->getInvoiceHtml->execute($userId, $id);
            http_response_code(200);
            header('Content-Type: text/html; charset=utf-8');
            echo $html;
        } catch (\Throwable $e) {
            Response::json(['success' => false, 'error' => $e->getMessage()], 400);
        }
    }
}



================================================
FILE: Backend/src/Domain/Entity/parking.php
================================================
<?php
declare(strict_types=1);

namespace App\Domain\Entity;

use DateTimeImmutable;

final class Parking
{
    private int $id;
    private int $capacity;

    // GPS stockÃ© en string "lat,long" (rapide et suffisant pour lâ€™instant)
    private string $gps;

    // Tarif horaire
    private float $tarif;

    // Horaires
    private DateTimeImmutable $heureDebut;
    private DateTimeImmutable $heureFin;

    // Relations (pour plus tard)
    private array $list_reservation;
    private array $list_stationnement;

    public function __construct(
        int $id,
        int $capacity,
        string $gps,
        float $tarif,
        DateTimeImmutable $heureDebut,
        DateTimeImmutable $heureFin,
        array $list_stationnement = [],
        array $list_reservation = []
    ) {
        if ($capacity < 0) {
            throw new \InvalidArgumentException('capacity must be >= 0');
        }

        $this->id = $id;
        $this->capacity = $capacity;
        $this->gps = $gps;
        $this->tarif = $tarif;
        $this->heureDebut = $heureDebut;
        $this->heureFin = $heureFin;
        $this->list_reservation = $list_reservation;
        $this->list_stationnement = $list_stationnement;
    }

    /* ============================
       IdentitÃ© & capacitÃ©
       ============================ */

    public function id(): int
    {
        return $this->id;
    }

    public function capacity(): int
    {
        return $this->capacity;
    }

    /* ============================
       AccÃ¨s FR (legacy)
       ============================ */

    public function getGps(): string
    {
        return $this->gps;
    }

    public function getTarif(): float
    {
        return $this->tarif;
    }

    public function getHeureDebut(): DateTimeImmutable
    {
        return $this->heureDebut;
    }

    public function getHeureFin(): DateTimeImmutable
    {
        return $this->heureFin;
    }

    public function getListReservation(): array
    {
        return $this->list_reservation;
    }

    public function getListStationnement(): array
    {
        return $this->list_stationnement;
    }

    /* ============================
       Aliases EN (API / UseCases)
       ============================ */

    public function gps(): string
    {
        return $this->getGps();
    }

    public function hourlyRate(): float
    {
        return $this->getTarif();
    }

    public function openingTime(): DateTimeImmutable
    {
        return $this->getHeureDebut();
    }

    public function closingTime(): DateTimeImmutable
    {
        return $this->getHeureFin();
    }
}



================================================
FILE: Backend/src/Domain/Entity/Reservation.php
================================================
<?php

namespace App\Domain\Entity;

final class Reservation
{
    public function __construct(
        private ?int $id,
        private int $userId,
        private int $parkingId,
        private \DateTimeImmutable $startAt,
        private \DateTimeImmutable $endAt,
        private \DateTimeImmutable $createdAt,
        private string $vehicleType,
        private float $amount,
    ) {
        if ($endAt <= $startAt) {
            throw new \InvalidArgumentException("endAt must be after startAt");
        }
        if ($this->vehicleType === '') {
            throw new \InvalidArgumentException("vehicleType is required");
        }
        if ($this->amount < 0) {
            throw new \InvalidArgumentException("amount must be >= 0");
        }
    }

    public static function create(
        int $userId,
        int $parkingId,
        \DateTimeImmutable $startAt,
        \DateTimeImmutable $endAt,
        string $vehicleType,
        float $amount
    ): self {
        return new self(
            null,
            $userId,
            $parkingId,
            $startAt,
            $endAt,
            new \DateTimeImmutable('now'),
            $vehicleType,
            $amount
        );
    }

    public function id(): ?int { return $this->id; }
    public function userId(): int { return $this->userId; }
    public function parkingId(): int { return $this->parkingId; }
    public function startAt(): \DateTimeImmutable { return $this->startAt; }
    public function endAt(): \DateTimeImmutable { return $this->endAt; }
    public function createdAt(): \DateTimeImmutable { return $this->createdAt; }
    public function vehicleType(): string { return $this->vehicleType; }
    public function amount(): float { return $this->amount; }

    public function withId(int $id): self
    {
        return new self(
            $id,
            $this->userId,
            $this->parkingId,
            $this->startAt,
            $this->endAt,
            $this->createdAt,
            $this->vehicleType,
            $this->amount
        );
    }
}



================================================
FILE: Backend/src/Domain/Entity/Stationnement.php
================================================
<?php
declare(strict_types=1);

namespace App\Domain\Entity;

final class Stationnement
{
    public function __construct(
        private ?int $id,
        private int $reservationId,
        private \DateTimeImmutable $enteredAt,
        private ?\DateTimeImmutable $exitedAt,
        private ?float $billedAmount,
        private ?float $penaltyAmount,
        private \DateTimeImmutable $createdAt
    ) {}

    public static function enter(int $reservationId, \DateTimeImmutable $now): self
    {
        return new self(
            null,
            $reservationId,
            $now,
            null,
            null,
            null,
            new \DateTimeImmutable('now')
        );
    }

    public function id(): ?int { return $this->id; }
    public function reservationId(): int { return $this->reservationId; }
    public function enteredAt(): \DateTimeImmutable { return $this->enteredAt; }
    public function exitedAt(): ?\DateTimeImmutable { return $this->exitedAt; }
    public function billedAmount(): ?float { return $this->billedAmount; }
    public function penaltyAmount(): ?float { return $this->penaltyAmount; }
    public function createdAt(): \DateTimeImmutable { return $this->createdAt; }

    public function withId(int $id): self
    {
        return new self($id, $this->reservationId, $this->enteredAt, $this->exitedAt, $this->billedAmount, $this->penaltyAmount, $this->createdAt);
    }
}



================================================
FILE: Backend/src/Domain/Entity/User.php
================================================
<?php
declare(strict_types=1);

namespace App\Domain\Entity;

final class User
{
    public function __construct(
        private int $id,
        private string $email,
        private string $passwordHash,
        private string $role = 'USER',

        private ?string $firstname = null,
        private ?string $lastname = null,

        // Config 2FA
        private bool $twoFactorEnabled = true,
        // 'email' | 'sms' | 'totp'
        private string $twoFactorMethod = 'email',

        // 2FA par code (email / sms)
        private ?string $twoFactorLastCode = null,
        private ?\DateTimeImmutable $twoFactorExpiresAt = null,

        // 2FA SMS
        private ?string $twoFactorPhone = null,

        // 2FA TOTP (Google Authenticator, etc.)
        private ?string $twoFactorTotpSecret = null,
    ) {
    }

    // ====================
    // Getters de base
    // ====================

    public function id(): int
    {
        return $this->id;
    }

    public function email(): string
    {
        return $this->email;
    }

    public function passwordHash(): string
    {
        return $this->passwordHash;
    }

    public function role(): string
    {
        return $this->role;
    }

    public function firstname(): ?string
    {
        return $this->firstname;
    }
    public function lastname(): ?string
    {
        return $this->lastname;
    }
    // ====================
    // 2FA - configuration
    // ====================

    public function twoFactorEnabled(): bool
    {
        return $this->twoFactorEnabled;
    }

    public function twoFactorMethod(): string
    {
        return $this->twoFactorMethod;
    }

    public function twoFactorPhone(): ?string
    {
        return $this->twoFactorPhone;
    }

    public function twoFactorTotpSecret(): ?string
    {
        return $this->twoFactorTotpSecret;
    }

    // immuable : config complÃ¨te de la 2FA (mÃ©thode + Ã©ventuel numÃ©ro)
    public function withTwoFactorConfig(
        bool $enabled,
        string $method,
        ?string $phone = null
    ): self {
        $allowed = ['email', 'sms', 'totp'];
        if (!\in_array($method, $allowed, true)) {
            throw new \InvalidArgumentException('Invalid 2FA method');
        }

        $c = clone $this;
        $c->twoFactorEnabled = $enabled;
        $c->twoFactorMethod = $method;
        $c->twoFactorPhone = $phone;

        return $c;
    }

    // Pour TOTP uniquement
    public function withTotpSecret(string $secret): self
    {
        $c = clone $this;
        $c->twoFactorTotpSecret = $secret;
        return $c;
    }

    public function hasTotpConfigured(): bool
    {
        return $this->twoFactorTotpSecret !== null && $this->twoFactorTotpSecret !== '';
    }

    // ====================
    // 2FA - challenge code (email / sms)
    // ====================

    public function twoFactorLastCode(): ?string
    {
        return $this->twoFactorLastCode;
    }

    public function twoFactorExpiresAt(): ?\DateTimeImmutable
    {
        return $this->twoFactorExpiresAt;
    }

    public function with2FACode(string $code, \DateTimeImmutable $expires): self
    {
        $c = clone $this;
        $c->twoFactorLastCode = $code;
        $c->twoFactorExpiresAt = $expires;
        return $c;
    }

    public function clear2FA(): self
    {
        $c = clone $this;
        $c->twoFactorLastCode = null;
        $c->twoFactorExpiresAt = null;
        return $c;
    }

    public function hasValid2FACode(string $code, \DateTimeImmutable $now): bool
    {
        if ($this->twoFactorLastCode === null || $this->twoFactorExpiresAt === null) {
            return false;
        }

        if ($this->twoFactorExpiresAt < $now) {
            return false;
        }

        return hash_equals($this->twoFactorLastCode, $code);
    }
}



================================================
FILE: Backend/src/Domain/Repository/ParkingRepository.php
================================================
<?php

namespace App\Domain\Repository;

use App\Domain\Entity\Parking;

interface ParkingRepository
{
    public function create(array $data): int;

    public function findById(int $id): ?Parking;

    /** @return array<int, array<string,mixed>> */
    public function listByOwnerId(int $ownerId): array;
    public function findOwnerIdByParkingId(int $parkingId): ?int;

}



================================================
FILE: Backend/src/Domain/Repository/ReservationRepository.php
================================================
<?php

namespace App\Domain\Repository;

use App\Domain\Entity\Reservation;

interface ReservationRepository
{
    public function findById(int $id): ?Reservation;

    public function save(Reservation $reservation): Reservation;

    /** @return Reservation[] */
    public function findByUserId(int $userId): array;

    /** @return Reservation[] */
    public function findByParkingId(int $parkingId): array;

    public function countOverlappingForParking(
        int $parkingId,
        \DateTimeImmutable $startAt,
        \DateTimeImmutable $endAt
    ): int;
    /** @return array<int, array<string,mixed>> */
    public function listByParking(int $parkingId, ?string $from, ?string $to): array;

    public function countOverlappingNotEntered(int $parkingId, string $startAt, string $endAt): int;

}



================================================
FILE: Backend/src/Domain/Repository/StationnementRepository.php
================================================
<?php
declare(strict_types=1);

namespace App\Domain\Repository;

use App\Domain\Entity\Stationnement;

interface StationnementRepository
{
    public function save(Stationnement $s): Stationnement;

    public function findActiveByReservationId(int $reservationId): ?Stationnement;

    public function close(
        int $stationnementId,
        \DateTimeImmutable $exitedAt,
        float $billedAmount,
        float $penaltyAmount
    ): void;

    public function findLastByReservationId(int $reservationId): ?Stationnement;
    /** @return array<int, array<string,mixed>> */
    public function listActiveByParkingId(int $parkingId): array;
    public function countActiveByParkingId(int $parkingId): int;

/** @return array{count_exits:int, total_billed:float, total_penalty:float, total:float} */
public function revenueForParking(string $from, string $to, int $parkingId): array;

}



================================================
FILE: Backend/src/Domain/Repository/UserRepository.php
================================================
<?php
declare(strict_types=1);

namespace App\Domain\Repository;

use App\Domain\Entity\User;

interface UserRepository
{
    public function findById(int $id): ?User;
    public function findByEmail(string $email): ?User;

    // ğŸ‘‡ on remplace save2FA par Ã§a
    public function save(User $user): void;
  public function create(
    string $email,
    string $passwordHash,
    string $role = 'USER',
    ?string $firstname = null,
    ?string $lastname = null
): User;
}



================================================
FILE: Backend/src/Domain/Repository/Exception/DomainException.php
================================================
<?php
declare(strict_types=1);

namespace App\Domain\Exception;

final class DomainException extends \RuntimeException {}



================================================
FILE: Backend/src/Infrastructure/Http/IsGranted.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Http;

use App\Infrastructure\Security\JwtManager;

#[\Attribute(\Attribute::TARGET_METHOD)]
final class IsGranted
{
    public function __construct(private string $role = 'USER') {}

    public function assert(JwtManager $jwt): void
    {
        $payload = $jwt->readAccessFromCookie();

        if (!$payload) {
            Response::json(['error' => 'Unauthorized'], 401);
            exit;
        }

        // âœ… Normalisation: Ã©vite OWNER vs owner, USER vs user, etc.
        $userRole = strtoupper((string)($payload['role'] ?? 'USER'));
        $needed   = strtoupper((string)$this->role);

        $ranks = [
            'USER'  => 1,
            'OWNER' => 2,
            'ADMIN' => 3,
        ];

        if (($ranks[$userRole] ?? 0) < ($ranks[$needed] ?? 99)) {
            Response::json(['error' => 'Forbidden'], 403);
            exit;
        }
    }
}



================================================
FILE: Backend/src/Infrastructure/Http/Response.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Http;

final class Response
{
    public static function json(array $data, int $status = 200): void
    {
        http_response_code($status);
        header('Content-Type: application/json; charset=utf-8');
        echo json_encode($data, JSON_UNESCAPED_UNICODE);
    }
}



================================================
FILE: Backend/src/Infrastructure/Http/Router.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Http;

use ReflectionMethod;

final class Router
{
    /** @var array<string, array<int, array{path:string, handler:mixed, regex:?string, vars:array<int,string>}>> */
    private array $routes = [];

    public function get(string $path, $handler): self { return $this->map('GET', $path, $handler); }
    public function post(string $path, $handler): self { return $this->map('POST', $path, $handler); }

    public function map(string $method, string $path, $handler): self
    {
        $path = rtrim($path, '/');
        if ($path === '') $path = '/';

        [$regex, $vars] = $this->compilePath($path);

        $this->routes[$method][] = [
            'path' => $path,
            'handler' => $handler,
            'regex' => $regex,
            'vars' => $vars,
        ];

        return $this;
    }

public function dispatch(string $method, string $path): void
{
    $path = rtrim($path, '/');
    if ($path === '') $path = '/';

    [$handler, $params] = $this->match($method, $path);

    if (!$handler) {
        Response::json(['error' => 'Not found'], 404);
        return;
    }

    if (is_array($handler) && is_object($handler[0])) {
        $controller = $handler[0];
        $methodName = $handler[1];

        $this->applyGuards($controller, $methodName);

        $this->call($handler, $params);
        return;
    }

    if (is_array($handler) && is_string($handler[0])) {
        $obj = new $handler[0]();
        $this->call([$obj, $handler[1]], $params);
        return;
    }

    $this->call($handler, $params);
}


    private function match(string $method, string $path): array
    {
        $routes = $this->routes[$method] ?? [];

        foreach ($routes as $route) {
            // Exact match first
            if ($route['regex'] === null && $route['path'] === $path) {
                return [$route['handler'], []];
            }

            // Regex match for {vars}
            if ($route['regex'] !== null && preg_match($route['regex'], $path, $m)) {
                $params = [];
                foreach ($route['vars'] as $varName) {
                    if (isset($m[$varName])) {
                        $params[] = ctype_digit($m[$varName]) ? (int)$m[$varName] : $m[$varName];
                    }
                }
                return [$route['handler'], $params];
            }
        }

        return [null, []];
    }

    private function compilePath(string $path): array
    {
        if (strpos($path, '{') === false) {
            return [null, []];
        }

        $vars = [];
        $regex = preg_replace_callback('/\{([a-zA-Z_][a-zA-Z0-9_]*)\}/', function ($m) use (&$vars) {
            $vars[] = $m[1];
            return '(?P<' . $m[1] . '>[^/]+)';
        }, $path);

        return ['#^' . $regex . '$#', $vars];
    }

    private function applyGuards(object $controller, string $methodName): void
    {
        $ref = new ReflectionMethod($controller, $methodName);
        $attributes = $ref->getAttributes(IsGranted::class);

        foreach ($attributes as $attribute) {
            $instance = $attribute->newInstance();

            // If controller has method jwt(): JwtManager
            if (method_exists($controller, 'jwt')) {
                $instance->assert($controller->jwt());
                continue;
            }

            // If controller has readable property $jwt
            if (property_exists($controller, 'jwt')) {
                try {
                    /** @phpstan-ignore-next-line */
                    $instance->assert($controller->jwt);
                    continue;
                } catch (\Throwable) {
                    Response::json(['error' => 'Controller JWT is not accessible'], 500);
                    exit;
                }
            }

            Response::json(['error' => 'Controller missing JWT'], 500);
            exit;
        }
    }

    private function call($handler, array $params): void
    {
        if (is_array($handler)) {
            call_user_func_array($handler, $params);
            return;
        }

        // Closure
        call_user_func($handler, ...$params);
    }
}



================================================
FILE: Backend/src/Infrastructure/Persistence/SqlParkingRepository.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Persistence;

use App\Domain\Entity\Parking;
use App\Domain\Repository\ParkingRepository;
use PDO;

final class SqlParkingRepository implements ParkingRepository
{
    public function __construct(private PDO $db) {}

public function create(array $data): int
{
    $stmt = $this->db->prepare("
        INSERT INTO parkings (owner_id, latitude, longitude, capacity, hourly_rate, opening_time, closing_time)
        VALUES (:owner_id, :lat, :lng, :cap, :rate, :open, :close)
    ");

    $stmt->execute([
        ':owner_id' => (int)($data['owner_id'] ?? 0),
        ':lat'      => (float)($data['latitude'] ?? 0),
        ':lng'      => (float)($data['longitude'] ?? 0),
        ':cap'      => (int)($data['capacity'] ?? 0),
        ':rate'     => (float)($data['hourly_rate'] ?? 0),
        ':open'     => (string)($data['opening_time'] ?? '00:00:00'),
        ':close'    => (string)($data['closing_time'] ?? '23:59:59'),
    ]);

    return (int)$this->db->lastInsertId();
}


    public function findById(int $id): ?Parking
    {
        $stmt = $this->db->prepare("
            SELECT
              id,
              latitude,
              longitude,
              capacity,
              hourly_rate,
              opening_time,
              closing_time
            FROM parkings
            WHERE id = :id
            LIMIT 1
        ");
        $stmt->execute([':id' => $id]);
        $row = $stmt->fetch(PDO::FETCH_ASSOC);

        if (!$row) {
            return null;
        }

        $gps = $row['latitude'] . "," . $row['longitude'];

        return new Parking(
            (int)$row['id'],
            (int)$row['capacity'],
            (string)$gps,
            (float)$row['hourly_rate'],
            new \DateTimeImmutable((string)$row['opening_time']),
            new \DateTimeImmutable((string)$row['closing_time']),
            [],
            []
        );
    }

    public function listByOwnerId(int $ownerId): array
    {
        // Ajuste le SELECT selon tes colonnes rÃ©elles.
        // Ici je pars sur une table parkings avec owner_id + latitude/longitude/etc.
        $stmt = $this->db->prepare('
            SELECT
              id,
              latitude,
              longitude,
              capacity,
              hourly_rate,
              opening_time,
              closing_time
            FROM parkings
            WHERE owner_id = :owner_id
            ORDER BY id DESC
        ');
        $stmt->execute(['owner_id' => $ownerId]);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    public function findOwnerIdByParkingId(int $parkingId): ?int
    {
        $stmt = $this->db->prepare('
            SELECT owner_id
            FROM parkings
            WHERE id = :id
            LIMIT 1
        ');
        $stmt->execute(['id' => $parkingId]);

        $ownerId = $stmt->fetchColumn();
        return $ownerId !== false ? (int)$ownerId : null;
    }
}



================================================
FILE: Backend/src/Infrastructure/Persistence/SqlReservationRepository.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Persistence;

use App\Domain\Entity\Reservation;
use App\Domain\Repository\ReservationRepository;
use PDO;

final class SqlReservationRepository implements ReservationRepository
{
    public function __construct(private PDO $db) {}

    public function save(Reservation $reservation): Reservation
    {
        if ($reservation->id() === null) {
            $stmt = $this->db->prepare("
                INSERT INTO reservations (user_id, parking_id, start_at, end_at, vehicle_type, amount, created_at)
                VALUES (:user_id, :parking_id, :start_at, :end_at, :vehicle_type, :amount, :created_at)
            ");

            $stmt->execute([
                ':user_id' => $reservation->userId(),
                ':parking_id' => $reservation->parkingId(),
                ':start_at' => $reservation->startAt()->format('Y-m-d H:i:s'),
                ':end_at' => $reservation->endAt()->format('Y-m-d H:i:s'),
                ':vehicle_type' => $reservation->vehicleType(),
                ':amount' => $reservation->amount(),
                ':created_at' => $reservation->createdAt()->format('Y-m-d H:i:s'),
            ]);

            return $reservation->withId((int)$this->db->lastInsertId());
        }

        // Si plus tard tu veux update, tu le feras ici.
        return $reservation;
    }

    public function findById(int $id): ?Reservation
    {
        $stmt = $this->db->prepare("SELECT * FROM reservations WHERE id = :id LIMIT 1");
        $stmt->execute([':id' => $id]);

        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return $row ? $this->hydrate($row) : null;
    }

    public function findByUserId(int $userId): array
    {
        $stmt = $this->db->prepare("
            SELECT *
            FROM reservations
            WHERE user_id = :uid
            ORDER BY start_at DESC
        ");
        $stmt->execute([':uid' => $userId]);

        return array_map([$this, 'hydrate'], $stmt->fetchAll(PDO::FETCH_ASSOC));
    }

    public function findByParkingId(int $parkingId): array
    {
        $stmt = $this->db->prepare("
            SELECT *
            FROM reservations
            WHERE parking_id = :pid
            ORDER BY start_at DESC
        ");
        $stmt->execute([':pid' => $parkingId]);

        return array_map([$this, 'hydrate'], $stmt->fetchAll(PDO::FETCH_ASSOC));
    }

    public function countOverlappingForParking(int $parkingId, \DateTimeImmutable $startAt, \DateTimeImmutable $endAt): int
    {
        $stmt = $this->db->prepare("
            SELECT COUNT(*) as c
            FROM reservations
            WHERE parking_id = :pid
              AND start_at < :end_at
              AND end_at > :start_at
        ");
        $stmt->execute([
            ':pid' => $parkingId,
            ':start_at' => $startAt->format('Y-m-d H:i:s'),
            ':end_at' => $endAt->format('Y-m-d H:i:s'),
        ]);

        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return (int)($row['c'] ?? 0);
    }

    /**
     * Version "Owner" pour listing simple en tableaux (pas des Entities),
     * avec filtre optionnel from/to.
     */
    public function listByParking(int $parkingId, ?string $from, ?string $to): array
    {
        $sql = '
            SELECT id, user_id, parking_id, start_at, end_at, vehicle_type, amount, created_at
            FROM reservations
            WHERE parking_id = :parking_id
        ';

        $params = ['parking_id' => $parkingId];

        if ($from) {
            $sql .= ' AND end_at >= :from';
            $params['from'] = $from;
        }
        if ($to) {
            $sql .= ' AND start_at <= :to';
            $params['to'] = $to;
        }

        $sql .= ' ORDER BY start_at ASC';

        $stmt = $this->db->prepare($sql);
        $stmt->execute($params);

        return $stmt->fetchAll(PDO::FETCH_ASSOC);
    }

    private function hydrate(array $row): Reservation
    {
        return new Reservation(
            (int)$row['id'],
            (int)$row['user_id'],
            (int)$row['parking_id'],
            new \DateTimeImmutable((string)$row['start_at']),
            new \DateTimeImmutable((string)$row['end_at']),
            new \DateTimeImmutable((string)$row['created_at']),
            (string)$row['vehicle_type'],
            (float)$row['amount']
        );
    }
    public function countOverlappingNotEntered(int $parkingId, string $startAt, string $endAt): int
{
    $stmt = $this->db->prepare('
        SELECT COUNT(*)
        FROM reservations r
        LEFT JOIN stationnements s 
          ON s.reservation_id = r.id
         AND s.exited_at IS NULL
        WHERE r.parking_id = :parking_id
          AND NOT (r.end_at <= :start_at OR r.start_at >= :end_at)
          AND s.id IS NULL
    ');

    $stmt->execute([
        'parking_id' => $parkingId,
        'start_at'   => $startAt,
        'end_at'     => $endAt,
    ]);

    return (int)$stmt->fetchColumn();
}

}



================================================
FILE: Backend/src/Infrastructure/Persistence/SqlStationnementRepository.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Persistence;

use App\Domain\Entity\Stationnement;
use App\Domain\Repository\StationnementRepository;
use PDO;

final class SqlStationnementRepository implements StationnementRepository
{
    public function __construct(private PDO $db) {}

    public function save(Stationnement $s): Stationnement
    {
        if ($s->id() === null) {
            $stmt = $this->db->prepare("
                INSERT INTO stationnements (reservation_id, entered_at, exited_at, billed_amount, penalty_amount, created_at)
                VALUES (:rid, :entered, :exited, :billed, :penalty, :created)
            ");
            $stmt->execute([
                ':rid' => $s->reservationId(),
                ':entered' => $s->enteredAt()->format('Y-m-d H:i:s'),
                ':exited' => $s->exitedAt()?->format('Y-m-d H:i:s'),
                ':billed' => $s->billedAmount(),
                ':penalty' => $s->penaltyAmount(),
                ':created' => $s->createdAt()->format('Y-m-d H:i:s'),
            ]);

            return $s->withId((int)$this->db->lastInsertId());
        }

        return $s;
    }

    public function findActiveByReservationId(int $reservationId): ?Stationnement
    {
        $stmt = $this->db->prepare("
            SELECT * FROM stationnements
            WHERE reservation_id = :rid AND exited_at IS NULL
            ORDER BY entered_at DESC
            LIMIT 1
        ");
        $stmt->execute([':rid' => $reservationId]);
        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return $row ? $this->hydrate($row) : null;
    }

    public function close(int $stationnementId, \DateTimeImmutable $exitedAt, float $billedAmount, float $penaltyAmount): void
    {
        $stmt = $this->db->prepare("
            UPDATE stationnements
            SET exited_at = :exited, billed_amount = :billed, penalty_amount = :penalty
            WHERE id = :id
        ");
        $stmt->execute([
            ':id' => $stationnementId,
            ':exited' => $exitedAt->format('Y-m-d H:i:s'),
            ':billed' => $billedAmount,
            ':penalty' => $penaltyAmount,
        ]);
    }

    public function findLastByReservationId(int $reservationId): ?Stationnement
    {
        $stmt = $this->db->prepare("
            SELECT * FROM stationnements
            WHERE reservation_id = :rid
            ORDER BY entered_at DESC
            LIMIT 1
        ");
        $stmt->execute([':rid' => $reservationId]);
        $row = $stmt->fetch(PDO::FETCH_ASSOC);
        return $row ? $this->hydrate($row) : null;
    }

    private function hydrate(array $row): Stationnement
    {
        return new Stationnement(
            (int)$row['id'],
            (int)$row['reservation_id'],
            new \DateTimeImmutable($row['entered_at']),
            $row['exited_at'] ? new \DateTimeImmutable($row['exited_at']) : null,
            $row['billed_amount'] !== null ? (float)$row['billed_amount'] : null,
            $row['penalty_amount'] !== null ? (float)$row['penalty_amount'] : null,
            new \DateTimeImmutable($row['created_at'])
        );
    }

    public function listActiveByParkingId(int $parkingId): array
{
    $stmt = $this->db->prepare('
        SELECT
          s.id,
          s.reservation_id,
          s.entered_at,
          s.exited_at,
          s.billed_amount,
          s.penalty_amount,
          s.created_at
        FROM stationnements s
        JOIN reservations r ON r.id = s.reservation_id
        WHERE r.parking_id = :parking_id
          AND s.exited_at IS NULL
        ORDER BY s.entered_at DESC
    ');
    $stmt->execute(['parking_id' => $parkingId]);
    return $stmt->fetchAll(\PDO::FETCH_ASSOC);
}
public function countActiveByParkingId(int $parkingId): int
{
    $stmt = $this->db->prepare('
        SELECT COUNT(*)
        FROM stationnements s
        JOIN reservations r ON r.id = s.reservation_id
        WHERE r.parking_id = :parking_id
          AND s.exited_at IS NULL
    ');
    $stmt->execute(['parking_id' => $parkingId]);
    return (int)$stmt->fetchColumn();
}

public function revenueForParking(string $from, string $to, int $parkingId): array
{
    $stmt = $this->db->prepare('
        SELECT
          COUNT(*) AS count_exits,
          COALESCE(SUM(s.billed_amount), 0) AS total_billed,
          COALESCE(SUM(s.penalty_amount), 0) AS total_penalty,
          COALESCE(SUM(COALESCE(s.billed_amount,0) + COALESCE(s.penalty_amount,0)), 0) AS total
        FROM stationnements s
        JOIN reservations r ON r.id = s.reservation_id
        WHERE r.parking_id = :parking_id
          AND s.exited_at IS NOT NULL
          AND s.exited_at >= :from
          AND s.exited_at < :to
    ');

    $stmt->execute([
        'parking_id' => $parkingId,
        'from' => $from,
        'to' => $to,
    ]);

    $row = $stmt->fetch(\PDO::FETCH_ASSOC) ?: [];

    return [
        'count_exits'   => (int)($row['count_exits'] ?? 0),
        'total_billed'  => (float)($row['total_billed'] ?? 0),
        'total_penalty' => (float)($row['total_penalty'] ?? 0),
        'total'         => (float)($row['total'] ?? 0),
    ];
}

}



================================================
FILE: Backend/src/Infrastructure/Persistence/SqlUserRepository.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Persistence;

use App\Domain\Entity\User;
use App\Domain\Repository\UserRepository;
use PDO;

final class SqlUserRepository implements UserRepository
{
    public function __construct(private PDO $pdo) {}

    private function hydrate(array $r): User
    {
        return new User(
            (int)$r['id'],
            (string)$r['email'],
            (string)$r['password_hash'],
            (string)$r['role'],

            $r['firstname'] ?? null,
            $r['lastname'] ?? null,

            (bool)$r['two_factor_enabled'],
            (string)$r['two_factor_method'],
            $r['two_factor_last_code'] ?? null,
            !empty($r['two_factor_expires_at']) ? new \DateTimeImmutable($r['two_factor_expires_at']) : null,
            $r['two_factor_phone'] ?? null,
            $r['two_factor_totp_secret'] ?? null,
        );
    }

    public function findById(int $id): ?User
    {
        $st = $this->pdo->prepare('SELECT * FROM users WHERE id = ?');
        $st->execute([$id]);
        $r = $st->fetch(PDO::FETCH_ASSOC);
        return $r ? $this->hydrate($r) : null;
    }

    public function findByEmail(string $email): ?User
    {
        $st = $this->pdo->prepare('SELECT * FROM users WHERE email = ?');
        $st->execute([$email]);
        $r = $st->fetch(PDO::FETCH_ASSOC);
        return $r ? $this->hydrate($r) : null;
    }

    public function create(
        string $email,
        string $passwordHash,
        string $role = 'user',
        ?string $firstname = null,
        ?string $lastname = null
    ): User {
        $st = $this->pdo->prepare(
            "INSERT INTO users (email, password_hash, role, firstname, lastname, two_factor_enabled, two_factor_method)
             VALUES (?, ?, ?, ?, ?, 0, 'email')"
        );

        $st->execute([$email, $passwordHash, $role, $firstname, $lastname]);
        $id = (int)$this->pdo->lastInsertId();

        return new User(
            $id, $email, $passwordHash, $role,
            $firstname, $lastname,
            false, 'email', null, null, null, null
        );
    }

    public function save(User $u): void
    {
        $st = $this->pdo->prepare(
            "UPDATE users SET
                email = ?,
                password_hash = ?,
                role = ?,
                firstname = ?,
                lastname = ?,
                two_factor_enabled = ?,
                two_factor_method = ?,
                two_factor_last_code = ?,
                two_factor_expires_at = ?,
                two_factor_phone = ?,
                two_factor_totp_secret = ?
             WHERE id = ?"
        );

        $exp = $u->twoFactorExpiresAt()?->format('Y-m-d H:i:s');

        $st->execute([
            $u->email(),
            $u->passwordHash(),
            $u->role(),
            $u->firstname(),
            $u->lastname(),
            $u->twoFactorEnabled() ? 1 : 0,
            $u->twoFactorMethod(),
            $u->twoFactorLastCode(),
            $exp,
            $u->twoFactorPhone(),
            $u->twoFactorTotpSecret(),
            $u->id(),
        ]);
    }
}



================================================
FILE: Backend/src/Infrastructure/Security/JwtManager.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Security;

use Firebase\JWT\JWT;
use Firebase\JWT\Key;

final class JwtManager
{
    public function __construct(
        private string $secret,
        private int $accessTtl,
        private int $refreshTtl
    ) {
    }

    public function issueFor(int $userId, string $role): array
    {
        $now = time();
        $access = [
            'iat' => $now,
            'nbf' => $now,
            'exp' => $now + $this->accessTtl,
            'sub' => $userId,
            'role' => $role,
            'typ' => 'access'
        ];
        $refresh = [
            'iat' => $now,
            'nbf' => $now,
            'exp' => $now + $this->refreshTtl,
            'sub' => $userId,
            'typ' => 'refresh'
        ];
        return [$this->encode($access), $this->encode($refresh)];
    }

    public function encode(array $payload): string
    {
        return JWT::encode($payload, $this->secret, 'HS256');
    }

    public function decode(string $jwt): ?array
    {
        try {
            return (array) JWT::decode($jwt, new Key($this->secret, 'HS256'));
        } catch (\Throwable) {
            return null;
        }
    }

    // --- Cookies (HttpOnly)
    public function setAccessCookie(string $token): void
    {
        $this->cookie('ACCESS_TOKEN', $token, $this->accessTtl);
    }
    public function setRefreshCookie(string $token): void
    {
        $this->cookie('REFRESH_TOKEN', $token, $this->refreshTtl);
    }
    public function clearAuthCookies(): void
    {
        $this->cookie('ACCESS_TOKEN', '', -3600);
        $this->cookie('REFRESH_TOKEN', '', -3600);
        $this->cookie('P2_AUTH', '', -3600);
    }
    private function cookie(string $name, string $value, int $ttl): void
    {
        $secure = isset($_SERVER['HTTPS']) && $_SERVER['HTTPS'] === 'on';
        setcookie($name, $value, [
            'expires' => time() + $ttl,
            'path' => '/',
            'secure' => $secure,
            'httponly' => true,
            'samesite' => $secure ? 'None' : 'Lax'
        ]);
    }

    // --- Helpers â€œlectureâ€
    public function readAccessFromCookie(): ?array
    {
        $raw = $_COOKIE['ACCESS_TOKEN'] ?? '';
        return $raw ? $this->decode($raw) : null;
    }
    public function readRefreshFromCookie(): ?array
    {
        $raw = $_COOKIE['REFRESH_TOKEN'] ?? '';
        return $raw ? $this->decode($raw) : null;
    }

    // --- 2FA (pending token court)
    public function issuePending2FAToken(int $userId): string
    {
        $now = time();
        $p2 = ['iat' => $now, 'nbf' => $now, 'exp' => $now + 300, 'sub' => $userId, 'typ' => 'p2'];
        return $this->encode($p2);
    }
    public function setPending2FACookie(string $token): void
    {
        $this->cookie('P2_AUTH', $token, 300);
    }
    public function readPending2FA(): ?array
    {
        $raw = $_COOKIE['P2_AUTH'] ?? '';
        return $raw ? $this->decode($raw) : null;
    }
}



================================================
FILE: Backend/src/Infrastructure/Security/PasswordHasher.php
================================================
<?php
declare(strict_types=1);

namespace App\Infrastructure\Security;

final class PasswordHasher {
  public function hash(string $plain): string {
    return password_hash($plain, PASSWORD_ARGON2ID);
  }
  public function verify(string $plain, string $hash): bool {
    return password_verify($plain, $hash);
  }
}



================================================
FILE: Backend/src/UseCase/CreateReservation.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase;

use App\Domain\Entity\Reservation;
use App\Domain\Repository\ParkingRepository;
use App\Domain\Repository\ReservationRepository;
use App\UseCase\Parking\CalculateOccupancy;

final class CreateReservation
{
    public function __construct(
        private readonly ParkingRepository $parkingRepo,
        private readonly ReservationRepository $reservationRepo,
        private readonly CalculateOccupancy $occupancy
    ) {}

    public function execute(
        int $userId,
        int $parkingId,
        string $startAt,
        string $endAt,
        string $vehicleType,
        float $amount
    ): Reservation {
        $parking = $this->parkingRepo->findById($parkingId);
        if ($parking === null) {
            throw new \RuntimeException('Parking not found');
        }

        // validation dates (sinon tu vas crÃ©er des rÃ©servations dÃ©biles)
        $start = new \DateTimeImmutable($startAt);
        $end   = new \DateTimeImmutable($endAt);
        if ($end <= $start) {
            throw new \RuntimeException('Invalid time range');
        }

        $capacity = $parking->capacity();

        // âœ… Occupation pour une nouvelle rÃ©servation = voitures dÃ©jÃ  prÃ©sentes + rÃ©servations du crÃ©neau pas encore entrÃ©es
        $occupied = $this->occupancy->totalForAvailability(
            $parkingId,
            $start->format('Y-m-d H:i:s'),
            $end->format('Y-m-d H:i:s')
        );

        if ($occupied >= $capacity) {
            throw new \RuntimeException('Parking full for this time slot');
        }

        $reservation = Reservation::create(
            $userId,
            $parkingId,
            $start,
            $end,
            $vehicleType,
            $amount
        );

        return $this->reservationRepo->save($reservation);
    }
}



================================================
FILE: Backend/src/UseCase/Auth/ConfigureTwoFactorMethod.php
================================================
class ConfigureTwoFactorMethod
{
    public function __construct(
        private UserRepository $userRepository
    ) {}

    public function execute(int $userId, string $method): array
    {
        $allowed = ['email', 'sms', 'totp'];
        if (!in_array($method, $allowed, true)) {
            throw new \InvalidArgumentException('Invalid 2FA method');
        }

        $user = $this->userRepository->findById($userId);

        if (!$user) {
            throw new \RuntimeException('User not found');
        }

        $user->enableTwoFactor($method);

        $qrData = null;

        if ($method === 'totp') {
            // GÃ©nÃ©ration dâ€™un secret TOTP (genre base32)
            $secret = $this->generateTotpSecret();
            $user->setTotpSecret($secret);

            // URI TOTP standard (pour les apps)
            $qrData = $this->buildTotpProvisioningUri($user->getEmail(), $secret);
        }

        $this->userRepository->save($user);

        return [
            'method' => $method,
            'totp_uri' => $qrData, // null si pas TOTP
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Auth/GetCurrentUser.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

use App\Infrastructure\Security\JwtManager;
use App\Domain\Repository\UserRepository;

final class GetCurrentUser {
  public function __construct(private JwtManager $jwt, private UserRepository $users) {}

  public function __invoke(): ?array {
    $p = $this->jwt->readAccessFromCookie();
    if (!$p || ($p['typ'] ?? '') !== 'access') return null;
    $u = $this->users->findById((int)$p['sub']);
    if (!$u) return null;
    return ['id'=>$u->id(), 'email'=>$u->email(), 'role'=>$u->role()];
  }
}



================================================
FILE: Backend/src/UseCase/Auth/LoginUser.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

use App\Domain\Repository\UserRepository;
use App\Infrastructure\Security\PasswordHasher;

final class LoginUser
{
    public function __construct(
        private UserRepository $users,
        private PasswordHasher $hasher,
    ) {}

    public function execute(string $email, string $password): array
    {
        $u = $this->users->findByEmail($email);

        if (!$u || !$this->hasher->verify($password, $u->passwordHash())) {
            return ['success' => false];
        }

        if ($u->twoFactorEnabled()) {
            return [
                'success'             => true,
                'two_factor_required' => true,
                'user_id'             => $u->id(),
                'role'                => $u->role(),
            ];
        }

        return [
            'success'             => true,
            'two_factor_required' => false,
            'user_id'             => $u->id(),
            'role'                => $u->role(),
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Auth/Mailer.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

interface Mailer
{
    public function sendTwoFactorCodeEmail(string $to, string $code): void;
}



================================================
FILE: Backend/src/UseCase/Auth/RefreshToken.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

use App\Infrastructure\Security\JwtManager;
use App\Domain\Repository\UserRepository;

final class RefreshToken
{
  public function execute(): ?array
  {
    return $this->__invoke();
  }

  public function __construct(private JwtManager $jwt, private UserRepository $users)
  {
  }

  /** @return array{access:string}|null */
  public function __invoke(): ?array
  {
    $refresh = $this->jwt->readRefreshFromCookie();
    if (!$refresh || ($refresh['typ'] ?? '') !== 'refresh') {
      return null;
    }
    $u = $this->users->findById((int) $refresh['sub']);
    if (!$u) {
      return null;
    }
    [$access,] = $this->jwt->issueFor($u->id(), $u->role());
    return ['access' => $access];
  }
}



================================================
FILE: Backend/src/UseCase/Auth/RegisterUser.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

use App\Domain\Repository\UserRepository;
use App\Infrastructure\Security\PasswordHasher;

final class RegisterUser
{
    public function __construct(
        private UserRepository $repo,
        private PasswordHasher $hasher
    ) {}

    public function execute(
        string $email,
        string $password,
        string $role= 'USER',
        ?string $firstname,
        ?string $lastname
    ): array {
        if ($this->repo->findByEmail($email)) {
            throw new \RuntimeException("Email already in use");
        }

        $hash = $this->hasher->hash($password);

        $user = $this->repo->create(
            $email,
            $hash,
            $role,
            $firstname,
            $lastname
        );

        return [
            'id' => $user->id(),
            'email' => $user->email(),
            'firstname' => $user->firstname(),
            'lastname' => $user->lastname(),
            'role' => $user->role(),
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Auth/SmsSender.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

interface SmsSender
{
    public function sendTwoFactorSms(string $phone, string $code): void;
}



================================================
FILE: Backend/src/UseCase/Auth/StartTwoFactor.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

use App\Domain\Repository\UserRepository;

final class StartTwoFactor
{
    public function __construct(
        private UserRepository $userRepository,
        private Mailer $mailer,
        private SmsSender $smsSender
    ) {}

    public function execute(int $userId): void
    {
        $user = $this->userRepository->findById($userId);

        if (!$user) {
            throw new \RuntimeException('User not found');
        }

        $method = $user->twoFactorMethod();

        // TOTP : pas de code Ã  gÃ©nÃ©rer, lâ€™app TOTP a dÃ©jÃ  le secret
        if ($method === 'totp') {
            return;
        }

        $code = str_pad((string) random_int(0, 999999), 6, '0', STR_PAD_LEFT);
        $expiresAt = (new \DateTimeImmutable())->modify('+5 minutes');

        // User est immuable -> on rÃ©cupÃ¨re la nouvelle instance
        $user = $user->with2FACode($code, $expiresAt);
        $this->userRepository->save($user);

        if ($method === 'email') {
            $this->mailer->sendTwoFactorCodeEmail($user->email(), $code);
        } elseif ($method === 'sms') {
            $phone = $user->twoFactorPhone();
            if ($phone === null) {
                throw new \RuntimeException('User has no phone number for SMS 2FA');
            }
            $this->smsSender->sendTwoFactorSms($phone, $code);
        } else {
            throw new \RuntimeException('Unknown 2FA method: '.$method);
        }
    }
}



================================================
FILE: Backend/src/UseCase/Auth/TotpVerifier.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

interface TotpVerifier
{
    public function verify(string $secret, string $code): bool;
}



================================================
FILE: Backend/src/UseCase/Auth/VerifyTwoFactor.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Auth;

use App\Domain\Repository\UserRepository;
use App\Infrastructure\Security\JwtManager;

final class VerifyTwoFactor
{
  public function __construct(
    private UserRepository $userRepository,
    private JwtManager $jwtManager,
    private TotpVerifier $totpVerifier
  ) {
  }

  public function execute(int $userId, string $code): array
  {
    $user = $this->userRepository->findById($userId);

    if (!$user) {
      throw new \RuntimeException('User not found');
    }

    $method = $user->twoFactorMethod();
    $now = new \DateTimeImmutable();

    $valid = false;

    if ($method === 'email' || $method === 'sms') {
      // helper du domaine
      $valid = $user->hasValid2FACode($code, $now);
    } elseif ($method === 'totp') {
      if (!$user->hasTotpConfigured()) {
        throw new \RuntimeException('TOTP not configured');
      }

      $secret = $user->twoFactorTotpSecret();
      if ($secret === null) {
        throw new \RuntimeException('Missing TOTP secret');
      }

      $valid = $this->totpVerifier->verify($secret, $code);
    } else {
      throw new \RuntimeException('Unknown 2FA method: ' . $method);
    }

    if (!$valid) {
      throw new \RuntimeException('Invalid 2FA code');
    }

    // Nettoyer le challenge pour email/sms
    if ($method === 'email' || $method === 'sms') {
      $user = $user->clear2FA();
      $this->userRepository->save($user);
    }

    // GÃ©nÃ©ration des JWT
    [$accessToken, $refreshToken] = $this->jwtManager->issueFor(
      $user->id(),
      $user->role()
    );

    return [
      'access_token' => $accessToken,
      'refresh_token' => $refreshToken,
    ];
  }
}



================================================
FILE: Backend/src/UseCase/Billing/BillingCalculator.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Billing;

final class BillingCalculator
{
    public function __construct(
        private readonly int $slotMinutes = 15,
        private readonly float $penaltyMultiplier = 2.0
    ) {}

    public function billedMinutes(\DateTimeImmutable $start, \DateTimeImmutable $end): int
    {
        $seconds = max(0, $end->getTimestamp() - $start->getTimestamp());
        $minutes = (int)ceil($seconds / 60);
        $slot = $this->slotMinutes;
        return (int)(ceil($minutes / $slot) * $slot);
    }

    public function amountForMinutes(int $minutes, float $hourlyRate): float
    {
        return round(($minutes / 60) * $hourlyRate, 2);
    }

    public function compute(
        \DateTimeImmutable $enteredAt,
        \DateTimeImmutable $exitedAt,
        \DateTimeImmutable $reservedEndAt,
        float $hourlyRate
    ): array {
        $billedMin = $this->billedMinutes($enteredAt, $exitedAt);
        $base = $this->amountForMinutes($billedMin, $hourlyRate);

        $penalty = 0.0;
        if ($exitedAt > $reservedEndAt) {
            $overtimeMin = $this->billedMinutes($reservedEndAt, $exitedAt);
            $overtimeAmount = $this->amountForMinutes($overtimeMin, $hourlyRate);
            $penalty = round($overtimeAmount * ($this->penaltyMultiplier - 1.0), 2); // surcharge, pas double facturation totale
        }

        return [
            'billed_minutes' => $billedMin,
            'base_amount' => $base,
            'penalty_amount' => $penalty,
            'total_amount' => round($base + $penalty, 2),
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Owner/GetMonthlyRevenueForOwner.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Owner;

use App\Domain\Repository\ParkingRepository;
use App\Domain\Repository\StationnementRepository;

final class GetMonthlyRevenueForOwner
{
    public function __construct(
        private readonly ParkingRepository $parkings,
        private readonly StationnementRepository $stationnements
    ) {}

    /** @return array<string,mixed> */
    public function execute(int $ownerId, int $parkingId, string $month): array
    {
        // month format: YYYY-MM
        if (!preg_match('/^\d{4}-\d{2}$/', $month)) {
            throw new \RuntimeException('Invalid month format. Expected YYYY-MM');
        }

        $ownerOfParking = $this->parkings->findOwnerIdByParkingId($parkingId);
        if ($ownerOfParking === null) {
            throw new \RuntimeException('Parking not found');
        }
        if ($ownerOfParking !== $ownerId) {
            throw new \RuntimeException('AccÃ¨s refusÃ©');
        }

        $from = new \DateTimeImmutable($month . '-01 00:00:00');
        $to = $from->modify('+1 month');

        $totals = $this->stationnements->revenueForParking(
            $from->format('Y-m-d H:i:s'),
            $to->format('Y-m-d H:i:s'),
            $parkingId
        );

        return [
            'parking_id' => $parkingId,
            'month' => $month,
            'from' => $from->format(\DATE_ATOM),
            'to' => $to->format(\DATE_ATOM),
            ...$totals,
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Owner/ListActiveStationnementsForOwner.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Owner;

use App\Domain\Repository\ParkingRepository;
use App\Domain\Repository\StationnementRepository;

final class ListActiveStationnementsForOwner
{
    public function __construct(
        private ParkingRepository $parkings,
        private StationnementRepository $stationnements
    ) {}

    public function execute(int $ownerId, int $parkingId): array
    {
        $parkingOwnerId = $this->parkings->findOwnerIdByParkingId($parkingId);
        if ($parkingOwnerId === null) {
            throw new \RuntimeException('Parking introuvable');
        }
        if ($parkingOwnerId !== $ownerId) {
            throw new \RuntimeException('AccÃ¨s refusÃ©');
        }

        return $this->stationnements->listActiveByParkingId($parkingId);
    }
}



================================================
FILE: Backend/src/UseCase/Owner/ListOwnerParkings.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Owner;

use App\Domain\Repository\ParkingRepository;

final class ListOwnerParkings
{
    public function __construct(private ParkingRepository $parkings) {}

    public function execute(int $ownerId): array
    {
        return $this->parkings->listByOwnerId($ownerId);
    }
}



================================================
FILE: Backend/src/UseCase/Owner/ListParkingReservationsForOwner.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Owner;

use App\Domain\Repository\ParkingRepository;
use App\Domain\Repository\ReservationRepository;

final class ListParkingReservationsForOwner
{
    public function __construct(
        private ParkingRepository $parkings,
        private ReservationRepository $reservations,
    ) {}

    public function execute(int $ownerId, int $parkingId, ?string $from, ?string $to): array
    {
        $parking = $this->parkings->findById($parkingId);
        if ($parking === null) {
            throw new \RuntimeException('Parking introuvable');
        }

        $parkingOwnerId = $this->parkings->findOwnerIdByParkingId($parkingId);
        if ($parkingOwnerId === null) {
            throw new \RuntimeException('Parking introuvable');
        }

        if ($parkingOwnerId !== $ownerId) {
            throw new \RuntimeException('AccÃ¨s refusÃ©');
        }

        return $this->reservations->listByParking($parkingId, $from, $to);
    }
}



================================================
FILE: Backend/src/UseCase/Parking/CalculateOccupancy.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Parking;

use App\Domain\Repository\ReservationRepository;
use App\Domain\Repository\StationnementRepository;

/**
 * Calcule l'occupation d'un parking.
 *
 * - NOW: voitures actuellement prÃ©sentes (stationnements actifs exited_at IS NULL)
 * - SLOT: occupation sur un crÃ©neau (rÃ©servations qui chevauchent le crÃ©neau),
 *         en excluant celles dÃ©jÃ  entrÃ©es si tu veux Ã©viter le double comptage.
 */
final class CalculateOccupancy
{
    public function __construct(
        private readonly StationnementRepository $stationnements,
        private readonly ReservationRepository $reservations
    ) {}

    /** Nombre de voitures actuellement dans le parking (temps rÃ©el). */
    public function now(int $parkingId): int
    {
        return $this->stationnements->countActiveByParkingId($parkingId);
    }

    /**
     * Occupation sur un crÃ©neau.
     * StratÃ©gie: rÃ©servations qui chevauchent le crÃ©neau
     * - en excluant celles dÃ©jÃ  entrÃ©es (sinon tu doubles: rÃ©servation + stationnement).
     */
    public function forSlot(int $parkingId, string $startAt, string $endAt): int
    {
        // rÃ©servations du crÃ©neau MAIS pas encore "entrÃ©es" (donc pas de stationnement actif)
        return $this->reservations->countOverlappingNotEntered($parkingId, $startAt, $endAt);
    }


    public function totalForAvailability(int $parkingId, string $startAt, string $endAt): int
    {
        return $this->now($parkingId) + $this->forSlot($parkingId, $startAt, $endAt);
    }
}



================================================
FILE: Backend/src/UseCase/Parking/CheckAvailability.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Parking;

use App\Domain\Repository\ParkingRepository;

final class CheckAvailability
{
    public function __construct(
        private readonly ParkingRepository $parkingRepo,
        private readonly CalculateOccupancy $occupancy
    ) {}

    public function execute(array $data): array
    {
        $parkingId = (int)($data['parking_id'] ?? 0);
        $startAt   = (string)($data['start_at'] ?? '');
        $endAt     = (string)($data['end_at'] ?? '');

        if ($parkingId <= 0 || $startAt === '' || $endAt === '') {
            throw new \RuntimeException('Missing fields');
        }

        $parking = $this->parkingRepo->findById($parkingId);
        if ($parking === null) {
            throw new \RuntimeException('Parking not found');
        }

        $capacity = $parking->capacity();

        // Occupation sur le crÃ©neau = prÃ©sents + rÃ©servÃ©s (pas encore entrÃ©s)
        $occupied = $this->occupancy->totalForAvailability($parkingId, $startAt, $endAt);

        $remaining = max(0, $capacity - $occupied);

        return [
            'parking_id' => $parkingId,
            'capacity'   => $capacity,
            'occupied'   => $occupied,
            'remaining'  => $remaining,
            'available'  => $remaining > 0,
            'start_at'   => (new \DateTimeImmutable($startAt))->format(DATE_ATOM),
            'end_at'     => (new \DateTimeImmutable($endAt))->format(DATE_ATOM),
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Parking/CreateParking.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Parking;

use App\Domain\Repository\ParkingRepository;

final class CreateParking
{
    public function __construct(private readonly ParkingRepository $parkingRepo) {}

    /**
     * @return array{parking_id:int}
     */
    public function execute(int $ownerId, array $data): array
    {
        $latitude    = $data['latitude'] ?? null;
        $longitude   = $data['longitude'] ?? null;
        $capacity    = (int)($data['capacity'] ?? 0);
        $hourlyRate  = $data['hourly_rate'] ?? null;
        $openingTime = (string)($data['opening_time'] ?? '');
        $closingTime = (string)($data['closing_time'] ?? '');

        if ($ownerId <= 0) {
            throw new \RuntimeException('Invalid owner');
        }

        if (!is_numeric($latitude) || !is_numeric($longitude) || $capacity <= 0 || !is_numeric($hourlyRate) || $openingTime === '' || $closingTime === '') {
            throw new \RuntimeException('Missing fields');
        }

        $id = $this->parkingRepo->create([
            'owner_id'     => $ownerId,
            'latitude'     => (float)$latitude,
            'longitude'    => (float)$longitude,
            'capacity'     => $capacity,
            'hourly_rate'  => (float)$hourlyRate,
            'opening_time' => $openingTime,
            'closing_time' => $closingTime,
        ]);

        return ['parking_id' => $id];
    }
}



================================================
FILE: Backend/src/UseCase/Parking/GetOwnerParkings.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Parking;

use App\Domain\Repository\ParkingRepository;
use Exception;

class GetOwnerParkings {
    private ParkingRepository $parkingRepo;

    public function __construct() {
        $this->parkingRepo = new ParkingRepository();
    }

    public function execute(array $user): array {
        if ($user['role'] !== 'owner') {
            throw new Exception('Non autorisÃ©', 401);
        }

        $parkings = $this->parkingRepo->findByOwner((int)$user['id']);
        return ['parkings' => $parkings];
    }
}



================================================
FILE: Backend/src/UseCase/Parking/GetOwnerStatistics.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Parking;

use App\Infrastructure\Repository\ReservationRepository;
use Exception;

class GetOwnerStatistics {
    private ReservationRepository $reservationRepo;

    public function __construct() {
        $this->reservationRepo = new ReservationRepository();
    }

    public function execute(array $user): array {
        if ($user['role'] !== 'owner') {
            throw new Exception('Non autorisÃ©', 401);
        }

        $revenue = $this->reservationRepo->getMonthlyRevenue((int)$user['id']);
        $activeReservations = $this->reservationRepo->countActiveByOwner((int)$user['id']);
        $activeStationnements = $this->reservationRepo->countActiveStationnementsByOwner((int)$user['id']);

        return [
            'revenus_mensuels' => $revenue,
            'reservations_en_cours' => $activeReservations,
            'stationnements_actifs' => $activeStationnements
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Parking/GetParkingDetails.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Parking;

use App\Domain\Repository\ParkingRepository;

final class GetParkingDetails
{
    public function __construct(
        private readonly ParkingRepository $parkingRepo
    ) {}

    public function execute(int $parkingId): array
    {
        $parking = $this->parkingRepo->findById($parkingId);
        if ($parking === null) {
            throw new \RuntimeException('Parking not found');
        }

        return [
            'id' => $parking->id(),
            'capacity' => $parking->capacity(),
            'gps' => $parking->gps(),
            'hourly_rate' => $parking->hourlyRate(),
            'opening_time' => $parking->openingTime()->format('H:i:s'),
            'closing_time' => $parking->closingTime()->format('H:i:s'),
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Parking/SearchParkings.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Parking;

use App\Infrastructure\Repository\ParkingRepository;
use App\Infrastructure\Repository\ReservationRepository;

class SearchParkings {
    private ParkingRepository $parkingRepo;
    private ReservationRepository $reservationRepo;

    public function __construct() {
        $this->parkingRepo = new ParkingRepository();
        $this->reservationRepo = new ReservationRepository();
    }

    public function execute(array $params): array {
        $filters = [
            'ville' => $params['ville'] ?? '',
            'vehicule' => $params['vehicule'] ?? ''
        ];
        $sort = $params['sort'] ?? null;
        $dateDebut = $params['dateDebut'] ?? null;
        $dateFin = $params['dateFin'] ?? null;

        $parkings = $this->parkingRepo->findAll($filters, $sort);

        // Si on a des dates, on calcule la dispo rÃ©elle
        if ($dateDebut && $dateFin) {
            foreach ($parkings as &$parking) {
                $reserved = $this->reservationRepo->countConfirmed((int)$parking['id'], $dateDebut, $dateFin);
                $parking['places_disponibles'] = max(0, $parking['nombre_places'] - $reserved);
            }
        } else {
            // Sinon on affiche le total
            foreach ($parkings as &$parking) {
                $parking['places_disponibles'] = $parking['nombre_places'];
            }
        }

        return [
            'parkings' => $parkings,
            'total' => count($parkings)
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Reservation/EnterReservation.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Reservation;

use App\Domain\Repository\ReservationRepository;
use App\Domain\Repository\StationnementRepository;
use App\Domain\Entity\Stationnement;

final class EnterReservation
{
    public function __construct(
        private readonly ReservationRepository $reservationRepo,
        private readonly StationnementRepository $stationnementRepo
    ) {}

    public function execute(int $userId, int $reservationId): Stationnement
    {
        $res = $this->reservationRepo->findById($reservationId);
        if (!$res) {
            throw new \RuntimeException('Reservation not found');
        }

        if ($res->userId() !== $userId) {
            throw new \RuntimeException('Forbidden');
        }

        $now = new \DateTimeImmutable('now');

        // "rÃ©servation active" = now entre start et end
        if ($now < $res->startAt() || $now > $res->endAt()) {
            throw new \RuntimeException('Reservation not active');
        }

        $active = $this->stationnementRepo->findActiveByReservationId($reservationId);
        if ($active) {
            throw new \RuntimeException('Already entered');
        }

        $s = Stationnement::enter($reservationId, $now);
        return $this->stationnementRepo->save($s);
    }
}



================================================
FILE: Backend/src/UseCase/Reservation/ExitReservation.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Reservation;

use App\Domain\Repository\ReservationRepository;
use App\Domain\Repository\StationnementRepository;
use App\Domain\Repository\ParkingRepository;
use App\UseCase\Billing\BillingCalculator;

final class ExitReservation
{
    public function __construct(
        private readonly ReservationRepository $reservationRepo,
        private readonly StationnementRepository $stationnementRepo,
        private readonly ParkingRepository $parkingRepo,
        private readonly BillingCalculator $billing
    ) {}

    public function execute(int $userId, int $reservationId): array
    {
        $res = $this->reservationRepo->findById($reservationId);
        if (!$res) throw new \RuntimeException('Reservation not found');
        if ($res->userId() !== $userId) throw new \RuntimeException('Forbidden');

        $active = $this->stationnementRepo->findActiveByReservationId($reservationId);
        if (!$active) throw new \RuntimeException('Not entered');

        $parking = $this->parkingRepo->findById($res->parkingId());
        if (!$parking) throw new \RuntimeException('Parking not found');

        $now = new \DateTimeImmutable('now');

        $calc = $this->billing->compute(
            $active->enteredAt(),
            $now,
            $res->endAt(),
            $parking->hourlyRate()
        );

        $this->stationnementRepo->close(
            (int)$active->id(),
            $now,
            (float)$calc['base_amount'],
            (float)$calc['penalty_amount']
        );

        return [
            'reservation_id' => $reservationId,
            'exited_at' => $now->format(DATE_ATOM),
            'base_amount' => $calc['base_amount'],
            'penalty_amount' => $calc['penalty_amount'],
            'total_amount' => $calc['total_amount'],
            'billed_minutes' => $calc['billed_minutes'],
        ];
    }
}



================================================
FILE: Backend/src/UseCase/Reservation/GetInvoiceHtml.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Reservation;

use App\Domain\Repository\ReservationRepository;
use App\Domain\Repository\StationnementRepository;
use App\Domain\Repository\ParkingRepository;

final class GetInvoiceHtml
{
    public function __construct(
        private readonly ReservationRepository $reservationRepo,
        private readonly StationnementRepository $stationnementRepo,
        private readonly ParkingRepository $parkingRepo
    ) {}

    public function execute(int $userId, int $reservationId): string
    {
        $res = $this->reservationRepo->findById($reservationId);
        if (!$res) throw new \RuntimeException('Reservation not found');
        if ($res->userId() !== $userId) throw new \RuntimeException('Forbidden');

        $parking = $this->parkingRepo->findById($res->parkingId());
        if (!$parking) throw new \RuntimeException('Parking not found');

        $st = $this->stationnementRepo->findLastByReservationId($reservationId);

        $entered = $st?->enteredAt()?->format('Y-m-d H:i:s') ?? 'â€”';
        $exited  = $st?->exitedAt()?->format('Y-m-d H:i:s') ?? 'â€”';

        $base = $st?->billedAmount();
        $pen  = $st?->penaltyAmount();
        $total = ($base ?? 0) + ($pen ?? 0);

        return "<!doctype html>
<html lang='fr'>
<head>
<meta charset='utf-8'>
<title>Facture rÃ©servation #{$reservationId}</title>
<style>
body{font-family:Arial,sans-serif;margin:24px;color:#111}
h1{margin:0 0 12px}
.card{border:1px solid #ddd;border-radius:10px;padding:16px;margin:12px 0}
.row{display:flex;justify-content:space-between;margin:6px 0}
.small{color:#555;font-size:12px}
</style>
</head>
<body>
<h1>Facture - RÃ©servation #{$reservationId}</h1>
<div class='small'>GÃ©nÃ©rÃ©e le ".date('Y-m-d H:i:s')."</div>

<div class='card'>
  <h3>RÃ©servation</h3>
  <div class='row'><div>Parking</div><div>#{$res->parkingId()}</div></div>
  <div class='row'><div>DÃ©but rÃ©servÃ©</div><div>{$res->startAt()->format('Y-m-d H:i:s')}</div></div>
  <div class='row'><div>Fin rÃ©servÃ©e</div><div>{$res->endAt()->format('Y-m-d H:i:s')}</div></div>
  <div class='row'><div>VÃ©hicule</div><div>{$res->vehicleType()}</div></div>
</div>

<div class='card'>
  <h3>Stationnement</h3>
  <div class='row'><div>EntrÃ©e</div><div>{$entered}</div></div>
  <div class='row'><div>Sortie</div><div>{$exited}</div></div>
</div>

<div class='card'>
  <h3>Montants</h3>
  <div class='row'><div>Base</div><div>".($base !== null ? number_format($base, 2, ',', ' ') . " â‚¬" : "â€”")."</div></div>
  <div class='row'><div>PÃ©nalitÃ©</div><div>".($pen !== null ? number_format($pen, 2, ',', ' ') . " â‚¬" : "â€”")."</div></div>
  <hr>
  <div class='row'><strong>Total</strong><strong>".number_format($total, 2, ',', ' ')." â‚¬</strong></div>
</div>

<div class='small'>Tarif horaire parking: ".number_format($parking->hourlyRate(), 2, ',', ' ')." â‚¬</div>
</body>
</html>";
    }
}



================================================
FILE: Backend/src/UseCase/Reservation/GetUserReservations.php
================================================
<?php
declare(strict_types=1);

namespace App\UseCase\Reservation;

use App\Infrastructure\Repository\ReservationRepository;

class GetUserReservations {
    private ReservationRepository $reservationRepo;

    public function __construct() {
        $this->reservationRepo = new ReservationRepository();
    }

    public function execute(array $user): array {
        $reservations = $this->reservationRepo->findByUser((int)$user['id']);
        return ['reservations' => $reservations];
    }
}



================================================
FILE: Backend/tests/Domain/JwtManagerTest.php
================================================
<?php
declare(strict_types=1);

namespace Tests\Domain;

use App\Infrastructure\Security\JwtManager;
use PHPUnit\Framework\TestCase;

final class JwtManagerTest extends TestCase
{
    private JwtManager $jwt;

    protected function setUp(): void
    {

        $this->jwt = new JwtManager('test-secret-key', 3600, 7200);
    }

    public function testIssueForReturnsTwoValidTokens(): void
    {
        [$access, $refresh] = $this->jwt->issueFor(42, 'USER');


        $this->assertIsString($access);
        $this->assertIsString($refresh);
        $this->assertNotSame($access, $refresh);


        $accessPayload  = $this->jwt->decode($access);
        $refreshPayload = $this->jwt->decode($refresh);

        $this->assertNotNull($accessPayload);
        $this->assertNotNull($refreshPayload);

        // Access token : bon sub / role / typ
        $this->assertSame(42, $accessPayload['sub'] ?? null);
        $this->assertSame('USER', $accessPayload['role'] ?? null);
        $this->assertSame('access', $accessPayload['typ'] ?? null);

        // Refresh token : bon sub / typ
        $this->assertSame(42, $refreshPayload['sub'] ?? null);
        $this->assertSame('refresh', $refreshPayload['typ'] ?? null);

        // Les deux ont un exp
        $this->assertArrayHasKey('exp', $accessPayload);
        $this->assertArrayHasKey('exp', $refreshPayload);
    }

    public function testDecodeReturnsNullForInvalidToken(): void
    {
        $result = $this->jwt->decode('ceci-n-est-pas-un-jwt');
        $this->assertNull($result);
    }

    public function testIssuePending2FATokenHasTypeP2(): void
    {
        $token   = $this->jwt->issuePending2FAToken(99);
        $payload = $this->jwt->decode($token);

        $this->assertNotNull($payload);
        $this->assertSame(99, $payload['sub'] ?? null);
        $this->assertSame('p2', $payload['typ'] ?? null);
    }
}



================================================
FILE: Backend/tests/Infrastructure/Security/PasswordHasherTest.php
================================================
<?php

declare(strict_types=1);

namespace Tests\Infrastructure\Security;

use App\Infrastructure\Security\PasswordHasher;
use PHPUnit\Framework\TestCase;

final class PasswordHasherTest extends TestCase
{
    public function testHashIsNotPlainPassword(): void
    {
        $hasher = new PasswordHasher();
        $plain  = 'MySecurePassword123!';
        $hash   = $hasher->hash($plain);

        $this->assertIsString($hash);
        $this->assertNotSame($plain, $hash, 'Le hash ne doit pas Ãªtre le mot de passe en clair');
        $this->assertGreaterThan(20, strlen($hash), 'Le hash doit Ãªtre suffisamment long');
    }

    public function testVerifyReturnsTrueWithCorrectPassword(): void
    {
        $hasher = new PasswordHasher();
        $plain  = 'Secret123!';
        $hash   = $hasher->hash($plain);

        $this->assertTrue($hasher->verify($plain, $hash));
    }

    public function testVerifyReturnsFalseWithWrongPassword(): void
    {
        $hasher = new PasswordHasher();
        $hash   = $hasher->hash('correct-password');

        $this->assertFalse($hasher->verify('wrong-password', $hash));
    }
}



================================================
FILE: Backend/tests/UseCase/Auth/InMemoryUserRepository.php
================================================
<?php
declare(strict_types=1);

namespace Tests\UseCase\Auth;

use App\Domain\Entity\User;
use App\Domain\Repository\UserRepository;

final class InMemoryUserRepository implements UserRepository
{
    /** @var User[] */
    private array $users = [];
    private int $autoIncrement = 1;

    public function __construct(User ...$users)
    {
        foreach ($users as $user) {
            $this->save($user);
        }
    }

    public function create(
        string $email,
        string $passwordHash,
        string $role = 'USER',
        ?string $firstname = null,
        ?string $lastname = null
    ): User {
        $user = new User(
            $this->autoIncrement++,
            $email,
            $passwordHash,
            $role,
            $firstname,
            $lastname,
        );
        $this->save($user);
        return $user;
    }

    public function findById(int $id): ?User
    {
        return $this->users[$id] ?? null;
    }

    public function findByEmail(string $email): ?User
    {
        foreach ($this->users as $user) {
            if ($user->email() === $email) {
                return $user;
            }
        }
        return null;
    }

    public function save(User $user): void
    {
        $this->users[$user->id()] = $user;

        if ($user->id() >= $this->autoIncrement) {
            $this->autoIncrement = $user->id() + 1;
        }
    }
}



================================================
FILE: Backend/tests/UseCase/Auth/LoginUserTest.php
================================================
<?php
declare(strict_types=1);

namespace Tests\UseCase\Auth;

use App\Domain\Entity\User;
use App\Domain\Repository\UserRepository;
use App\Infrastructure\Security\PasswordHasher;
use App\UseCase\Auth\LoginUser;
use PHPUnit\Framework\TestCase;

/**
 * Petit repository en mÃ©moire uniquement pour les tests.
 */
final class InMemoryUserRepository implements UserRepository
{
    /** @var User[] */
    private array $users = [];
    private int $autoIncrement = 1;

    public function __construct(User ...$users)
    {
        foreach ($users as $user) {
            $this->save($user);
        }
    }

    public function create(string $email, string $passwordHash, string $role = 'USER',    ?string $firstname = null,
    ?string $lastname = null): User
    {
        $user = new User($this->autoIncrement++, $email, $passwordHash, $role);
        $this->save($user);
        return $user;
    }

    public function findById(int $id): ?User
    {
        return $this->users[$id] ?? null;
    }

    public function findByEmail(string $email): ?User
    {
        foreach ($this->users as $user) {
            if ($user->email() === $email) {
                return $user;
            }
        }
        return null;
    }

    public function save(User $user): void
    {
        $this->users[$user->id()] = $user;

        if ($user->id() >= $this->autoIncrement) {
            $this->autoIncrement = $user->id() + 1;
        }
    }
}

/**
 * Tests du cas dâ€™usage LoginUser.
 */
final class LoginUserTest extends TestCase
{
    private PasswordHasher $hasher;

    protected function setUp(): void
    {
        $this->hasher = new PasswordHasher();
    }

    public function testLoginSucceedsWithValidCredentialsAnd2FAEnabled(): void
    {
        $plain = 'MyStrongPassword!';
        $hash  = $this->hasher->hash($plain);

        // 2FA activÃ©e par dÃ©faut
        $user = new User(
            1,
            'user@example.com',
            $hash,
            'USER'
        );

        $repo    = new InMemoryUserRepository($user);
        $useCase = new LoginUser($repo, $this->hasher);

        $result = $useCase->execute('user@example.com', $plain);

        $this->assertTrue($result['success'] ?? false);
        $this->assertTrue($result['two_factor_required'] ?? false);
        $this->assertSame(1, $result['user_id'] ?? null);
        $this->assertSame('USER', $result['role'] ?? null);
    }

    public function testLoginSucceedsWithValidCredentialsAnd2FADisabled(): void
    {
        $plain = 'MyStrongPassword!';
        $hash  = $this->hasher->hash($plain);

        // On dÃ©sactive la 2FA via withTwoFactorConfig
        $user = new User(
            2,
            'no2fa@example.com',
            $hash,
            'USER'
        );
        $user = $user->withTwoFactorConfig(false, 'email');

        $repo    = new InMemoryUserRepository($user);
        $useCase = new LoginUser($repo, $this->hasher);

        $result = $useCase->execute('no2fa@example.com', $plain);

        $this->assertTrue($result['success'] ?? false);
        $this->assertFalse($result['two_factor_required'] ?? true);
        $this->assertSame(2, $result['user_id'] ?? null);
        $this->assertSame('USER', $result['role'] ?? null);
    }

    public function testLoginFailsWithWrongPassword(): void
    {
        $plain = 'MyStrongPassword!';
        $hash  = $this->hasher->hash($plain);

        $user = new User(
            3,
            'user@example.com',
            $hash,
            'USER'
        );

        $repo    = new InMemoryUserRepository($user);
        $useCase = new LoginUser($repo, $this->hasher);

        $result = $useCase->execute('user@example.com', 'wrong-password');

        $this->assertFalse($result['success'] ?? true);
        $this->assertArrayNotHasKey('user_id', $result);
        $this->assertArrayNotHasKey('role', $result);
    }

    public function testLoginFailsWithUnknownUser(): void
    {
        $repo    = new InMemoryUserRepository(); // aucun user enregistrÃ©
        $useCase = new LoginUser($repo, $this->hasher);

        $result = $useCase->execute('doesnotexist@example.com', 'whatever');

        $this->assertFalse($result['success'] ?? true);
        $this->assertArrayNotHasKey('user_id', $result);
        $this->assertArrayNotHasKey('role', $result);
    }
}


